1. 当一个类没有显式定义移动构造函数,但是有用户自定义的拷贝构造函数时,如果你尝试移动一个对象(如通过`std::move`),拷贝构造函数会被调用,而不是移动构造函数
2. 如果类中没有定义任何拷贝或移动构造函数,编译器会生成默认的拷贝构造函数和移动构造函数;如果类中定义了拷贝构造函数或拷贝赋值运算符,则编译器不会生成移动构造函数和移动赋值运算符;如果类中定义了移动构造函数或移动赋值运算符,则编译器不会生成拷贝构造函数和拷贝赋值运算符
3. 二叉平衡树(<=>二叉平衡搜索树)的查找、删除和插入操作的时间复杂度都是`O(logn)`(红黑树是二叉平衡树的一种特例),但是其删除和插入可能会伴随节点的旋转,即最坏情况下,可能需要`O(logn)`次旋转操作,即此时的插入和删除的时间总复杂度就是`O(logn)+O(logn)`
4. `vector<pair<>>`可以直接用`sort`,此时是按字典序排序.`pair`已经重载了`<`运算符,它会先比较`first`,如果不同则决定顺序;如果`first`相同,再比较`second`
5. 二叉搜索树的查找、插入、删除时间复杂度均为`O(logn)`,它不会旋转节点;二叉平衡搜索树时间复杂度一样,但是它的插入和删除可能会旋转节点,调整全局结构
6. 负载均衡算法：
   * 轮询算法：按顺序将请求依次分配给服务器列表中的每台服务器。缺点：性能差的服务器可能过载；
   * 加权轮询：可以给高性能服务器分配大权重，使其获得更多请求；
   * IP哈希：根据客户端IP地址计算哈希值，然后固定映射到一台服务器。缺点：IP集中度太高的话可能导致单点过载；
   * 一致性哈希：将服务器与请求映射到哈希环，对请求计算哈希值，然后请求按顺时针分配给最近的节点，让这个节点进行处理这个请求。这种方式可以在新增或删除服务器节点时对原哈希环影响最小，只会影响相邻节点；
   * 最少连接数(动态负载均衡算法)：优先将请求分配给当前活跃连接数最少的服务器，需要动态感知连接数；
7. 内联函数(内联函数不需要常规函数那样的来回调用，没有入栈、出栈的开销)、宏、const、constexpr的区别
   * 处理阶段：
     - 编译阶段；
     - 预编译阶段；
     - 编译期或运行期；
     - 编译期；
   * 原理：
     - 向编译器发出一个建议（编译器可以不采纳），建议编译器在编译阶段直接将函数展开，从而消除函数调用的开销；
     - 简单的文本替换，会产生多个副本；
     - 修饰变量、函数等，表示它不会改变，即只读；
     - 要求编译器在编译期间就计算并初始化该变量或函数的结果，将运算从运行时转移到编译时，以提高运行时的性能；  
8. Makefile：这是一个纯文本文件，它包含了构建一个项目所需的规则和依赖关系，无需额外的工具，只要有make即可（make编译源代码就是根据的makefile），makefile是cmake工具根据cmakelists.txt生成的；CMake是一个跨平台的自动化构建系统生成器，它不直接构建项目，而是根据CMakeLists.txt生成特点平台和编译器所需的本地构建文件（比如在linux中就是生成makefile）
9. C++高效率vector插入很多数据：如果直接push_back肯定会多次扩容，每次扩容都要重新分配内存，然后拷贝，再删除原内存，很耗时间。因此最好的方法是先reserve预留空间，减少扩容次数
10. C++容器是分配在哪个内存部分的
    * 容器本身是一个对象，它通常分配在栈内存（作为局部变量）或全局内存（如果是全局或静态变量）
    * 容器内部存储的元素是分配在堆内存的