1. shared_ptr一定是线程安全的吗？
   * 引用计数是线程安全的：这个引用计数的增加和减少是原子操作，因此是线程安全的
   * 所管理的对象不一定是线程安全的：如果多个线程通过不同的shared_ptr访问同一个对象，即共享资源，并且这些线程有可能修改该共享资源，那么就需要自行保证对该对象的访问是线程安全的，比如加锁。如:
    ```C++
    struct Counter {
        int value = 0;
    };
    void worker(std::shared_ptr<Counter> p) {
        for (int i = 0; i < 100'000; ++i) {
            ++p->value;          // 未加锁：多线程同时读写
        }
    }
    int main() {
        auto ptr = std::make_shared<Counter>();
        std::thread t1(worker, ptr);   // 拷贝 ptr，引用计数原子递增（安全）
        std::thread t2(worker, ptr);   // 同上
        t1.join();
        t2.join();
        std::cout << "Counter = " << ptr->value << '\n';  // 极大概率≠200000
    } 
    ```