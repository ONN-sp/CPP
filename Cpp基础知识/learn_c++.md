# 基础语法
1. C++对大小写字母敏感
2. C++用cout代替C中的`printf`,但是`cout`可以直接输出变量,不用加格式字符串,这和python类似.对于cout,系统会自动根据数据或变量类型进行输出
3. 双斜杠 `//`  注释
4. 预处理文件(头文件)`<iostream>`包括的是输入输出指令
5. 程序使用`cin`和`cout`作为输入和输出时必须`include<iostream>`文件
6. 新版C++协议的头文件是`iostream`,不是`iostream.h`,所以需要`namespace`指令来实现可以使用`iostream`中的定义
7. 命名空间可以作为附加信息来区分不同库中相同名称的函数、类、变量等
8. 所谓`namespace`,是指标识符的各种可见范围。C++标准程序库中的所有标识符(如:`cout`  `endl`等等)都被定义在`std`的`namespace`中(`using namespace std`操作可以使所有定义在`std`空间中的标识符都能在此程序中使用,可以理解为一个此程序中的全局声明)
9. `endl`是一个操作算子,它的作用就是换行+刷新缓冲区(是输出缓冲区),所以输出函数其实就是`cout`,`endl`只是起了个换行和刷新缓冲区的作用,输出的时候`endl`不是一定要有的
10. C++用`cout`输出换行的三种方式:
    ```C++
    eg:
    cout<<endl;
    cout<<'\n';
    cout<<"\n";
    ```
11. C++允许在创建变量时对它赋值
12. `climits`头文件中包含了关于整型限制的信息,具体来说,它定义了表示各种限制的符号名称
13. C++中定义了一种C中没有的初始化语法: 
    ```C++
    eg:
    int wrens(432) <=> int wrens = 432;
    ```
14. C++对字符用单引号,对字符串用双引号
15. C++为`cout`引入了一个`cout.put()`函数,类似C中的`putchar()`函数
16. `\`为转义字符
17. C++11 新增了类型`char16_t`和`char32_t`,其中前者是无符号16位,后者是无符号32位,定义方式为:
    ```C++
    eg:
    char16_t ch1 = u'q';
    char32_t ch2 = U'q';
    ```
18. 定义常量尽量用`const`, 因为它能够明确指定类型,并可以限制在特定的作用域中
19. C++中的自动类型转换:
    * 将一种算术类型值赋给另一种算术类型的变量时,C++将对值进行转换;
    * 表达式中包含不同的类型时,C++将对值进行转换;
    + 将参数传递给函数时,C++将对值进行转换;
20. 强制类型转换:`(typeName) value` OR `typeName value`
21. 查看变量类型:`typeid(variable).name()`
22. 定义常量
    ```C++
    //使用#define预处理器
    eg:
    #define SCREEN_HEIGHT 640//#define预定义不能有等号和分号
    //使用const关键字
    eg:
    const int SCREEN_WIDTH = 960;
    eg:
    //使用全局变量(非常变量)
    int SCREEN_WIDTH = 960;
    ```
23. 全局变量在整个源文件的作用域都有效,只需要在一个源文件中定义全局变量,在其他不包含该全局变量的源文件的头文件用`extern`关键字声明即可
24. `const`定义格式
    ```C++
    const typeName name = value;
    ```
25. 在用`cin`输入字符串时,它使用空白(空格、制表符和换行符)来确定输入字符串的结束位置,这意味着`cin`在获取字符数组输入时只读取一个单词,读取完后会自定在结尾添加空字符`'\0'`
26. <mark>`cout`(`cin`)是可以直接输出(输入)字符数组(字符串)的,但是对于其他类型数组只能遍历输出(输入)(遍历输出输入就是直接操作的单个元素变量名,而不是数组名)</mark>
    ```C++
    eg:
    int a[3]={1,2,3};×
    cout << a;//这输出不了1 2 3,它会输出变量a的值,即这个数组的首元素地址
    eg:
    int a[3];×
    cin >> a;//整数型数组不能直接对数组整体输入,只能单个元素的输入
    eg:
    int a[3];
    cin >> a[1];//整数型数组不能直接对数组整体输入,只能单个元素的输入
    ```
27. <mark>`C++`里面的`cin`和`cout`对单个元素变量的输入和输出可以直接对变量进行操作,而不像`C`中的格式化输入(需要取地址)和输出.`C++`对字符数组(字符串)的输入和输出可以直接操作数组名</mark>
28. `>>`与`<<`叫做流运算符
29. <mark>`C++`中其它函数的定义位置不重要,可以在`main()`之前和之后,但是这些函数的声明必须在调用这些函数之前</mark>
30. `void *`是一个通用的指针类型,它可以指向任何类型的数据.然后,使用`void *`需要小心,因为它失去了类型信息,需要在使用时进行强制类型转换
31. <mark>对数组名取地址得到的整个数组的地址</mark>
32. `cout << 'b'-'a' << endl;`输出1
33. <span style="color:red;">`C++代码块`通常指的是一段用花括号`{}`包围起来的`C++`代码,用于定义一个作用域.在这个作用域内声明的变量在作用域外是不可见的,这样可以限制变量的作用范围,提高代码的可读性和安全性</span>
# 数组
1. 数组声明应指出以下三点:
    * 存储在每个元素中的值的类型;
    * 数组名;
    + 数组中的元素数;
2. `typename arrayName[arraySize]` //<mark>表达式arraySize指定元素数目,它必须是整型常数(如10)或const值,也可以是常量表达式(如`8*sizeof(int)`)</mark>
3. 计算数组所含元素个数:
    ```C++
    eg:
    array_len = sizeof(array1) / sizeof(array1[0])
    ```
4. 只有在定义数组时才能使用初始化,以后就不能使用了,也不能将一个数组赋给另一个数组
5. 初始化数组时,提供的值可以少于数组的元素数目,其余编译器会自动补0
6. C++11 的列表初始化新增了一些功能:
    * 初始化数组,可以省略等号,如:
        ```C++
        eg:
        int arr1 {1, 2};
        ```
    * 初始化列表中可以不包含任何东西,这将把所有元素都设置为0;
    * 列表初始化禁止缩窄转换;
7. ![Alt text](markdwon图像集/image-10.png)字符串(字符数组)其实可以看作字符串起来再加一个`\0`
8. <mark>字符串的索引`str[i]`是一个字符类型(`char`)</mark>
# 字符串
1. C++处理字符串有两种方式:
    * C-风格字符串:以空字符`'\0'`结尾,在利用初始化列表`{'l','o','v','e','\0'}`初始化字符串时,要显示的在最后一位给`'\0'`,否则不是字符串
    * 可以利用字符串常量,如:`char str1 = "Love";`用引号括起的字符串隐式地包括结尾的空字符,因此不用显示地包括它,存储时系统会自动添加`'\0'`将字符串读到char str1数组中,会自动加上空字符
2. `"S"`表示的是两个字符(字符`'S'`和`'\0'`)
3. 拼接字符串:C++允许拼接字符串字面值,如: 
    ```C++
    eg:
    cout << "I" "Love" "You" << endl;
    ```
    拼接时第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符后,第一个字符串中的'\0'将被第二个字符串的第一个字符代替
4. `strlen()`函数返回的是存储在数组中的字符串的长度,而不是数组本身的长度,<mark>并且不把空字符计算在内</mark>
5. `cin`使用空白(空格、制表符和换行符)来确定字符串的结束位置,则`cin`只读取一个单词.`cin`输入完后会自动在结尾添加`'\0'`
6. `iostream`中的类对象(`cin`)提供了`getline()`和`get()`两个读取一行字符串的函数,<mark>它们两个都是通过换行符结尾</mark>,其中:
    * `getline()`将丢弃输入时的换行符(不会把换行符存到输入缓冲区中),而get()会保存换行符在输入序列(输入缓冲区)中:
    ```C++
    eg:
        cin.getline(ArrayName, ArraySize); //在存储字符串时,系统自动用空字符('\0')来替代输入结尾标志'\n'

        cin.get(arrayName, ArrarSize);//系统也会自动添加空字符('\0')
        //前面两种是cin的方法,需要指定数组个数.对于string对象:
        getline(cin, str);//输入也以换行符终止.getline()与cin.getline()一样,读取换行符,将换行符替换成'\0',并将换行符从输入缓冲区中抹去
    ```
    * 对于`cin.get()`,由于第一次调用后,换行符将留在输入队列中,因此第二次调用时看到的第一个字符便是换行符.为了处理换行符:
    ```C++
    eg:
    cin.get(Arrayname, ArraySize).get()//这里的.get()是为了舍弃输入流中的一个紧接的字符
    ```          
    * `cin`输入也会将换行符保存在输入队列(输入缓冲区)中,所以有时输入会莫名产生空行的情况
7. string类位于命名空间std中(<mark>C没有string类</mark>)
   ```C++
   * 可以使用C-风格字符串来初始化string对象
   * 可以使用cin来将键盘输入存储到string对象中
   * 可以使用cout来显示string对象
   * 可以使用数组表示法来索引/访问存储在string对象中的字符
   ```
8.  虽然`string`未规定需要用`'\0'`结尾,但是在用`C-`风格的字符串或者用`cin`输入字符串赋给`string`对象时,也会把`'\0'`赋给`strng`对象(这是显然的).`string`对象不会自动给字符串分配`'\0'`,它有的`'\0'`只是赋给它的,其实在`C++`里,`string`是不需要识别结尾的,因为需要用到的东西,`string`函数库都解决了
9.  C++中处理字符串的三种方法:
    * 字符数组:`char array[Size]`;
    * string类: `string str1`;
    * 指针;
10. string类设计让程序能自动处理string的大小
11. 对于string类:
    ```C++
    eg:
    字符串拼接: "+"
    字符串合并: "+=", str1 += str2 //将str2加到str1末尾
    字符串复制: str1 = str2
    字符串大小: .size(), str1.size()
    ```
12. 将一行输入读取到`string`对象中去
    ```C++
    getline(cin, str); //这里没用句点表示法,因为这个getline()不是类方法.另外,也没有指出字符串长度的参数,因为string对象将根据字符串的长度自动调整自己的大小
    ```
13. C++中增加了原始字符串,它用`"("和")"`定界,并使用前缀R来标识原始字符串.若要在原始字符串中输出小括号,则此时用`"+*("`和`")+*"`来替代定界符
14. `string`、字符数组、字符指针
    ```C++
    1. 字符指针有初始值时,不能修改其中字符的值
    char* p="sadsda";
    p[2]='2';
    //因为字符指针指向的是一个静态存储区const
    2. string允许修改
    string ss="sadsda";
    p[2]='2';
    3. 字符数组形式也允许修改
    char ss[26]="sadsda"
    p[2]='2';
    //因为字符数组放在栈内存中,属于动态内存区,允许修改
    ```    
# 结构体
1. C++允许在声明结构变量时省略关键字(如:`struct inflatable goose<=>inflatable goose`),这与C不同(C中不能省略)
2. 结构体访问结构成员变量是用成员运算符(`.`)
3. 使用结构体前需要先定义,通常放在main()函数前进行外部定义.定义中的成员是用分号(`;`)
4. 初始化时各成员是用逗号(`,`)隔开
5. 同类型的结构体可以直接赋值
6. 结构体初始化赋值可以直接花括号赋值
7. 可以同时完成定义结构和创建结构变量的工作
   ![Alt text](markdwon图像集/image-7.png)
8. 最好将结构体的定义和初始化分开,初始化时:
    ```C++
    inflatable 结构体名称; a={};
    ```
9.  结构数组:`inflatable gifts[100]`; //假定inflatable是已经定义的`结构体名称.gifts`是一个数组,其中的每个元素都是inflatable对象
10. 结构数组初始化时:结果为一个被括在花括号中、用逗号分隔的值列表,其中每个值本身又是一个被括在花括号中、用逗号隔开的值列表
11. C++允许指定占用特定位数的结构成员,每个成员都被称为位字段,但<mark>位字段编程一般用在低级编程中</mark>
12. 结构体中定义的成员变量既可以是同类型也可以是不同类型
13. ![Alt text](markdwon图像集/image-6.png)
    其中`inflatable`就像是一个标准的类型名,可以被用来定义变量
# 共用体
1. 共用体是一种数据格式,它能够存储不同的数据类型(这一点类似结构体),但是它<u>只能同时存储其中的一种类型</u>.
2. 共用体的定义与结构体类似,但是共用体不能像结构体那样利用列表整体赋值,union只能用点号(`.`)对成员单独赋值
3. <mark>共用体的长度为其最大成员的长度.共用体使用了内存覆盖技术,同一时刻只能保存一个成员的值,如果对新的成员赋值,就会覆盖原来成员的值,所以共用体中的成员变量赋值应该结合内存空间来想.覆盖时,一般从低位开始覆盖,所以有可能没完全覆盖,比如char类型不能覆盖完int类型.当且仅当成员所占字节数相同,否则只会覆盖相应字节上的值</mark>
4. 共用体常用来节省空间,当数据线使用多种(但不会同时使用)时,就可考虑union
5. 共用体赋值时注意事项:
    ```C++
    eg:
    1. 
    union id{
            int x;
            float y;
            };
    int main()
        {
        id z;
        z.x = 1;
        z.y = 2; 
        cout << z.x << " " << z.y << endl;
        return 0;
    };=>1073741824 2
    //z.x=1073741824的原因没想明白,好像是溢出值
    2.
    union id{
            int x;
            int y;
            }
    int main()
        {
        id z;
        z.x = 1;
        z.y = 2; 
        cout << z.x << " " << z.y << endl;
        return 0;
    }=>2 2
    //z.x和z.y在共用体内存字节上完全重合,则后一个修改值会使前一个值与它一样
    ```
# 枚举
1. `C++`提供了`eunm`工具来创建符号常量,<mark>这种方式可以代替const</mark>
   ```C++
   eg:
   enum spectrum {red, orange, yellow, green, blue};
   #spectrum为新类型的名称,被称为枚举
   #red,orange等为符号常量,它们对应整数值0~4.这些常量称为枚举量
   #对于枚举,只定义了赋值运算符,没有定义算术运算符
   #枚举量是整型,可被提升为int类型,但int类型不能自动转换为枚举类型(band=3是非法的)
   #枚举定义可以省略枚举类型名称
   ```
2. 可以显示地指定整数值来覆盖默认值
   ```C++
   eg:
   enum bits{one=1,two=2,four=4,eight}
   #指定的值必须是整数
   #没有初始化的枚举量的值将比其前面的枚举量大1,eight的值为5
   ```
3. 枚举定义的取值范围
   * 上限
     - 找到大于这个最大值的最小的2的幂,将它减去1,得到的便是取值范围的上限.如上面的最大枚举值是5,在2的幂中比它大的最小的为8,则上限为7.
   * 下限
     - 如果枚举量的最小值不小于0,则下限为0.
     - 否则,采用与找上限方式相同的方式,但加上负号
# 指针
1. 指针是一个变量,其存储的是值的地址,而不是值的本身
2. 指针强调的是允许阶段,而数组等是强调的编译阶段
3. 指针名表示的是**地址**,`*`运算符被称为间接值或解除引用运算符
4. 指针定义的形式
   ```C++
   eg:
   int *ptr #(True)
   int* ptr #(True),C++习惯用
   int*ptr #(True)
   ```
5. 对每个指针变量名都需要使用一个`*`
   ```C++
   eg:
   int* p1, p2; #这样定义的p2是一个int而不是int*
   ```
6. 指针的危险:<span style="color:red;">因为在创建指针时,计算机只会分配用来存储地址的内存,而不会分配指针的指向.因此,在对指针应用解除引用运算符(`*`)前,要将指针初始化为一个确定的、适当的地址.</span>
    ```C++
    eg:
    int* p1;
    *p1 = 2;
    #这样是错误的
    ```
7. C++中不能将地址值以数值的方式直接赋给指针(C可以)
   ```C++
   eg:
   int* p;
   p = 0xB8000000;
   #C++中不允许
   ```
8. `new`分配内存和`delete`释放内存
    * new分配内存(运行阶段,可以编写程序边定义),它使程序在管理内存方面有更大的控制权
        ```C++
        1.
        //为一个数据对象(可以是结构,也可以是基本类型)获得并指定分配内存的格式
        typeName* pointer_name = new typeName;
        #new运算符根据类型来确定需要多少字节的内存.然后,它找到这样的内存,并返回其地址
        2.
        new分配的内存块通常与常规变量声明分配的内存块不同.变量的值都存储在被称为栈的内存中,而new从被称为堆或自由存储区的内存中分配内存
        3.
        //使用new来创建动态数组
        typeName* pointer_name = new typeName [num_elements]; #pointer_name指向第一个元素(和数组中的数组名一样)
        #如果通过声明来创建数组,则在程序被编译时将为它分配内存.在编译时给数组分配内存被称为静态联编.new分配是在程序允许时选择数组的长度,这种被称为动态联编
        ```
    * delete释放内存
        ```C++
        1.
        int* p = new int;
        ...
        delete p;
        #这将释放p指向的内存,但不会删除指针p本身
        2.
        new和delete一定要配对使用.否则将发生内存泄漏,也就是说,被分配的内存再也无法使用了
        3.
        //new和delete遵守的规则
         - 不要使用delete来释放不是new分配的内存
         - 不要使用delete释放同一个内存块两次
         - 如果使用new为数组分配内存,则应该使用delete []来释放
         - 如果使用new为一个实体分配内存,则应该使用delete来释放
         - 对空指针应用delete是安全
         4.
         释放动态数组内存时,要将数组指针的指向移到最初创建的位置.
         int* p = new array[3];
         p[0] = 1;
         p[1] = 2;
         p[2] = 3;
         p = p+1;
         cout << p[0] << endl;
         p = p-1;#必须有这一句
         delete [] p;
        ```
9. 不能修改数组名的值,但可以修改指针变量的值
10. <span style="color:red;">利用`new`分配内存创建的指针会给它一个指针的指向,所以不会出现`6.`中所说的指针的危险</span>
    ```C++
    eg:
    1. 
    int* p;
    *p = 1;
    cout << *p << endl;
    =>报错
    2. 
    int* p = new int;
    *p = 1;
    cout << *p << endl;
    =>1
    ```
11. 如果`p`是一个指向`int`的指针,那么`p+1`是导致它指向第2个元素.从地址角度看,`p`的值其实增加了一个`int`的字节数.<mark>指针变量加1,增加的量等于它指向的类型的字节数</mark>
12. 多数情况,C++将数组名解释为第一个元素的地址
13. 解除引用和数组表示法等价
    ```C++
    eg:
    *(stacks+1)<=>stacks[1]
    ```
14. 数组应用`sizeof`得到的是数组的字节长度,而对指针应用`sizeof`得到的是指针(该地址)的字节长度
15. 数组名被解释为其第一个元素的地址,而对数组名取地址(&)时,得到的是整个数组的地址
    ```C++
    eg:
    short tell[10];
    cout << tell << endl;
    coutr << &tell << endl;
    #从数字上说,这两个地址相同;但从概念上说,tell是以一个2字节内存块的地址,而&tell是一个20字节内存块的地址.因此,tell+1是将地址+20
    ``` 
16. 
    ```C++
    //数组指针:指向n个元素的数组的指针
    eg:
    int(* p) [n];
    //指针数组:数组中每一个元素都是一个指针,含有n个指针
    eg:
    int* p[n];
    ```
17. 在`cout`和多数C++表达式中,`char`数组名、`char`指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址
18. 地址赋值并不会复制字符串(不会得到字符串的副本),而只是复制地址.然后使这两个指针都指向相同的内存单元和字符串
19. <span style="color:red;">获得字符串副本(复制字符串,但地址不同)</span>
    ```C++
    char animal[10] = "bird";
    //首先需要分配内存来存储这个字符串
    ps = new char [strlen(animal) + 1];//+1是为了包含空字符
    //接下来需要将字符串复制到新分配的空间,不能直接赋值,因为这样只能复制地址
    strcpy(ps, animal);
    ```
20. `strcpy()`会复制`'\0'`,而`strncpy()`不会复制`'\0'`
21. <mark>使用`new`动态创建结构体</mark>
    ```C++
    inflatable* ps = new inflatable;
    ```
22. 访问结构体.如果结构标识符是结构名,则使用句点`.`运算符;如果标识符是指向结构的指针,则使用箭头运算符`->`
    ```C++
    //创建动态结构时,不能将成员运算符(.)用于结构名,因为这种结构没有名称,只是知道它的地址
    eg:
    inflatable* ps = new inflatable;
    ps->name <=> (*ps).name;
    ```
23. `strlen`不能统计字符串的空字符`'\0'`
24. `C++`三种内存管理方法
    ```s
    1. 自动存储:在函数内部定义的常规变量使用自动存储空间(栈->后进先出LIFO),被称为自动变量,它们在所属的函数被调用时自动产生,在该函数结束时消亡
    2. 静态存储是整个程序执行期间都存在的存储方式.使变量成为静态的方式有:
        - 函数外声明(全局)
        - 加关键字static
    3. 动态存储:new和delete管理了一个内存池(堆),堆和用于静态变量和自动变量的内存是分开的.使用new和delete能够在一个函数中分配内存,在另一个函数中释放它.因此,使用new和delete让程序员对程序如何使用内存有更大的控制权
    ```
25. 如果使用`new`在堆中创建变量后,没有`delete`,那么会发生<mark>内存泄露</mark>
26. `Vector`对象
    ```C++
    1. vector类似string类,也是一个动态数组.可以在运行阶段设置vector对象的长度,可在末尾附加新数据,还可以插入新数据.
    2. vertor是使用new创建动态数组的替代,vector本质管理内存还是new和delete,但这些工作是自动完成的
    3. 使用vector对象要包含头文件vector,还要包含命名空间std
    4. vertor<typeName> vt(n_elem);#创建一个保存typeName类型的vector对象vt,可存储n_elem个元素,n_elem可以是整型常量也可以是整型变量
    5. vector对象会根据vector包的各种方法(插入、删除等)自动调整长度
    6. vector对象使用堆
    7. vector类不能直接用cin输入(因为vector类中没有这个cin方法),要借用vector.push_back()这些方法
    8. vector类不能直接用cout打印动态数组名,可以用迭代的方法打印
    ```
27.  `array`对象
    ```C++
    1. 和数组一样,array对象的长度也是固定的,也使用栈,但它更方便、安全
    2. array<typeName, n_elem> arr;#创建了一个名为arr的array对象,但这的n_elem不能是变量
    ```
# 循环和关系表达式
1. 语句和表达式的区别就是一个分号`;`
2. 在`for`语句中声明的变量只能用在`for`语句中,当程序离开循环后,变量也会消失
3. 
    ```C++
    eg:
    using namespace std;//using编译指令,使所有的名称都可用
    using std::cout;//using声明,使一个名称cout可用,并且在后续使用中不用域解析运算符::
    //使用命名空间名称
    1. cout << 5;//使用using声明或编译指令后可直接用cout
    2. std::cout << 5;//无using指令,则需域解析运算符
    ```
4. `i++`表示使用`i`后再加1,`++i`表示先给`i`加1再使用`i`
5. `C++`文件的编译链接过程
   ```s
   预处理->编译(转换为汇编代码.编译的时候只检查函数声明,只要引用的函数声明了(头文件中声明也行)就行)->汇编(转换为机器码,汇编这一步需要为其他源文件生成一个机器码,即可执行文件)->链接(函数的定义是在链接检查的,链接将多个二进制目标文件和系统组件合成一个可执行文件)
   ```
6. 对于用户定义的类型,如果有用户定义的递增和递减运算符,则前缀格式(`++i`)的效率更高
7. 前缀递增`++i`、前缀递减`--i`和解除引用运算符`*`优先级相同,以从右到左的方式结合;后缀递增`i++`和后缀递减`i--`优先级相同,但比前缀高
   ```C++
   eg:
   *++pt;//先给pt加1,再将*应用于被递增后的pt
   eg:
   (*pt)++;//表示先对指针解除引用,然后++
   eg:
   x = *pt++;//先执行后缀递增,然后应用pt到*,注意这里后缀运算符是对原来地址而不是递增后的地址解除引用.x得到的是*pt的值,这条语句执行完毕后,pt的值将成为pt+1的地址(先用pt到语句,语句结束后再给pt+1)
   ```
8. 所有运算符中,逗号运算符是优先级最低的
9. 关系运算符的优先级比算术运算符低
10. 对于字符数组,是不能直接用关系运算符进行比较的,只能用`C-`风格字符串库的`strcmp()`函数进行比较.而对于`string`对象可以直接用关系运算符
11. `string`类重载了关系运算符,所以可以直接用关系运算符比较`string`对象,此时需要至少有一个操作数为`string`对象,另一个操作数可以是`C-`风格字符串
12. 字符可以直接用关系运算符比较,因为字符本质是整型
13. `while`不能像`for`那样在循环里面定义局部变量
14. 通常是在需要循环计数是用`for`,而无法预知循环次数时用`while`
15. `C++`创建别名
    ```C++
    eg:
    1. #define BYTE char* //BYT成为char的别名
    2. typedef char* byte;//通用格式为typedef typeName aliasName
    注意:
    * 使用#define建立别名定义指针时会出现和原始类型定义指针出现一样的问题,如:byte pa,pb;<=>char* pa,pb;此时pb只是一个char类型而不是指针
    * 但是用typedef不会出现上述问题
    * typedef是一种更佳的选择
    * typdedef不会创建新类型,它只是为己有类型建立一个别名
    ```
16. `C++`里面创建了一个测量程序时间的函数`clock()`,它会返回一个`clock_t`类型的值,这个值表示从程序启动到调用`clock()`函数所经过的时钟周期数
    ```C++
    #头文件ctime里面定义了一个符号常量-CLOCKS_PER_SEC,该常量等于每秒钟包含的系统时间单位数,因此将系统时间除以这个值就能得到秒数
    eg:
    clock_t start = clock();//记录程序启动到此刻的时间
    ...
    clock_t end = clock();//记录程序启动到此刻的时间周期数
    elapsed_tim = (end-start)/CLOCKS_PER_SEC;//计算中间程序块的运行时间(秒)
    ```
17. `C++`新增了一种循环:基于范围的`for`循环(对数组(或容器类,如`vector`和`array`)的每个元素执行相同的操作)
    ```C++
    for(int x : {1, 2, 3})//x必须在这声明,不能在外面声明,即for(x : {1, 2, 3})是错的
        cout << x << endl;
    //类似python中的for...in...
    ```
18. <span style="color:red;">文件尾条件`EOF`,许多PC的编程环境都将`ctrl+z`视为模拟的`EOF`.检测到`EOF`后,`cin`将两位(`eofbit`和`failbit`)都设置为1.如果`eofbit`或`failbit`被设置为1,则fail()/eof()成员函数(`cin`的成员函数)返回`true`,常用`fail()`方法</span>
19. `cin`方法检测到`EOF`时,将设置`cin`对象中一个指示`EOF`条件的标记.设置这个标记后,`cin`将不再读取输入,就算后面再次调用`cin`也不管用
20. `EOF`的常见输入做法
    ```C++
    1. 
        cin.get(ch);
        while(cin.fail() == false){
            ...
            cin.get(ch);
        }
    2.
        while(!cin.fail())
    3.
        //使用istream的对象作为条件时,效果是检查流的状态.若流有效,则该对象返回true,否则false.但是这个对象不能直接被输出,这是显然的
        eg:
        cout << cin;//(×)
        //cin是istream类的一个对象,而istream类提供了一个可以将istream对象(如cin)转换为bool值的函数,当istream类的对象(cin)出现在需要bool值的地方(如循环时的测试条件)会自动被转换为bool值,如果读取成功(则没读取到EOF)则返回true,否则false
        cin.get(ch);
        while(cin)
        {
            ...
            cin.get(ch);
        }
    4.
        //cin.get(char)返回值是一个cin对象
        while(cin.get(ch)){//此方法更通用,因为这样只需要调用一次cin.get()
            ...
        }
    5.
        //对于cin.get(),当该函数到达EOF时,将没有可返回的字符.相反,cin.get()将返回一个用符号常量EOF表示的特殊值,该常量在头文件iostream中定义.EOF值被定义为-1
        int ch;
        while((ch = cin.get())!=EOF){
            ...
        }
    ```
21. `cin.get()`与`cin.get(char)`的区别
    ![Alt text](markdwon图像集/image.png)
    <mark>注意:`cin.get(char arrayname, arraysize)`的函数返回值也是一个istream对象
22. 使用`cin.get(char)`可以拼接
    ```C++
    eg:
    cin.get(ch1).get(ch2);//cin.get(ch1)会返回一个cin对象,则可以继续调用get(ch2).将输入中的字符读入到ch1中,然后将接下来的字符读入ch2中
    ```
23. `cin >> `这种也会返回一个`istream`对象
24. <span style="color:red;">`cin`不仅在遇到文件结束符`EOF`时会返回无效状态,它在无效输入(如用一个字符去作为整型数的输入)时也会返回一个无效状态,即此时也返回`false`.但是非常重要的是,只有对`cin`进行直接输入流操作(输入类型为数值类型才行),而不调用其它类方法(如cin.get(char ch),ch=cin.get()等)时才会有类型无效,返回`false`,这可以作为判断输入是否为数值的一个方法</span>
    ```C++
    eg:
    int ch;
    ch = cin.get();//cin.get()返回的不是istream对象
    //输入abc ?
    //返回97('a'的ASCII码)
    eg:
    char ch;
    cin.get(ch);
    //输入123
    //返回1
    eg:
    int ch;//float类型也行
    cin >> ch;
    //输入abc ?
    //返回0=false=无效状态
    //输入a
    //返回0=false=无效状态
    #因此,只有输入数值型(int float double 等)时能触发无效状态(类型无效)
    eg:
    char ch;
    cin >> ch;
    //输入123
    //返回1
    ```
# 分支语句和逻辑运算符
1. `C++`中逻辑运算符有两种表示方法
```C++
&&  <=> and;
||  <=> or;
!   <=> not;
```
1. `cctype`中的字符函数
   ![Alt text](markdwon图像集/image-1.png)
   ![Alt text](markdwon图像集/image-2.png)
2. `C++`中唯一一个需要3个操作数的运算符->条件运算符
   ```C++
   expression1? expression2:expression3
   #如果expression=true,则条件表达式的值为expression2,否则为expression3
   ```
3. `switch`![Alt text](markdwon图像集/image-3.png)
4. 通常,`cin`无法识别枚举类型,但是当`switch`语句将`int`值和枚举量标签进行比较时,会将枚举量提升为`int`.另外,在`while`循环中,也会将枚举量提升为`int`类型
5. `siwthc`的判断值必须是整数(`char`也行),并且`case label`中的`label`必须是常量
6. `C++`也有`goto`语句,但是在大多数情况下`goto`语句不好
# 输入、输出和文件
1. 在计算机系统中是指信息从外部输入设备向计算机内部输入,或者从内存向外部输出设备输出的过程.<mark>这种输入输出的过程被形象的比喻为"流"</mark>
2. `C++`程序把输入和输出看作字节流.输入时,程序从输入流中抽取字节;输出时,程序将字节插入到输出流中.对于面向文本的程序,每个字节代表一个字符.简单的说,字节可以构成字符或数值数据的二进制表示(汇编阶段得到二进制文件),即字节是最小的"token"
3. ![Alt text](markdwon图像集/image-4.png)
4. <span style="color:red;">缓冲区可以高效地处理输入和输出,缓冲区是用作"中介"的内存块,它是将信息从设备传输到程序或从程序传输给设备的临时存储工具.缓冲区可以帮助匹配两端不同的信息传输速率</span>
5. <mark>刷新缓冲区是将缓冲区中的数据立刻写入文件,同时清空缓冲区</mark>(`endl`会刷新输出缓冲区)
6. <mark>`C++`中按下回车键不会直接刷新输入缓冲区</mark>(`C++`可以用`cin.ignore()`来清空输入缓冲区)
7. 缓冲区有三种:
    ```C++
    1. 全缓冲:当缓冲区填满时,才会刷新缓冲区并将数据写入目标地址
    2. 行缓冲:数据在传输过程中以行为单位进行缓冲存储.对于终端(如键盘、显示屏)进行输入和输出,当I/O流被设置为行缓冲模式(标准输入流,标准输出流就是行缓冲),输入的一行文本将在用户按下Enter键后一次性传给程序(不会等这个行缓冲区存满才传)
    3. 无缓冲:指在输入/输出操作中没有中间缓冲层的操作模式,在这种模式下,数据直接从程序到设备(输出)或从设备到程序(输入)进行传递,而不进行中间缓冲,这种情况实时性好,但系统开销大
   ```
8. 管理流和缓冲区的类
   ![Alt text](markdwon图像集/image-5.png)
   `streambuf`类为缓冲区提供了内存,并提供了用于填充缓冲区、访问缓冲区内容、刷新缓冲区和管理缓冲区内存的类方法,因此如:
   ```C++
   cout << "Bjarne free";//标准输出流通过指向的streambuf对象将字符串"Bjarne free"中的字符放到cout管理的输出缓冲区中
   ```
   `ios_base`类表示流的一般特征,如是否可读取、是二进制流还是文本流等
   `ios`类基于`los_base`,其中包括了一个指向`streambuf`对象的指针成员
   `ostream`类是从`ios`类派生而来的,提供了输出方法
   `istream`类是从`ios`类派生而来的,提供了输入方法
   `iostream`类是基于`ostream`和`istream`类的,因此继承了输入方法和输出方法
9. 在默认情况下,`cin`只能接收从键盘输入的数据,`cout`也只能将数据输出到屏幕上,但通过重定向,`cin`可以将指定文件作为输入流;同时`cout`可以将原本要输出到屏幕上的数据转而写到指定文件中
   ```C++
   1. 重定向标准输入
   #include <iostream>
   #include <fstream>
   int main(){
    //保存原始的输入流缓冲区
    std::streambuf* cinbuf = std::cin.rdbuf();
    //打开文件作为输入流
    std::ifstream in("input.txt");
    //将文件流的缓冲区设置为标准输入流的缓冲区
    std::cin.rdbuf(in.rdbuf());
    //cin读入进此时的输入缓冲区'
    cin >> ...
    //恢复原始的输入流缓冲区
    std::cin.rdbuf(cinbuf);
    return 0;
   }
   2. 重定向标准输入
   #include <iostream>
   #include <fstream>
   int main(){
    //保存原始的输出流缓冲区
    std::streambuf* coutbuf = std::cout.rdbuf();
    //打开文件作为输入流
    std::ifstream out("output.txt");
    //将文件流的缓冲区设置为标准输出流的缓冲区
    std::cout.rdbuf(out.rdbuf());
    //cout读入进此时的输出缓冲区'
    cout << ...
    //恢复原始的输出流缓冲区
    std::cout.rdbuf(coutbuf);
    return 0;
   }
   ```
10. 在程序中包好了`iostream`文化,将自动创建8个流对象(4个窄字符流:char等,4个宽字符流:wchar_t等)
   ```C++
   cin,wcin(行缓冲)
   cout,wcout(行缓冲)
   cerr/wcerr:与标准错误流相对应,可用于显示错误消息.默认情况下,这个流被关联到标准输出设备,这个流无缓冲
   clog/wclog:与标准错误流相对应,可用于显示错误消息.默认情况下,这个流被关联到标准输出设备,这个流为行缓冲
   ```
11. 在`C++`中,与`C`一样,`<<`运算符的默认含义是左移运算符,但`ostream`类重新定义了`<<`运算符,方法是将其<mark>重载为输出</mark>.此时,`<<`被称为插入运算符.插入运算符被重载,使之能够识别`C++`中所有基本类型
12. `ostream`类给每种数据类型都提供了`operator<<()`函数的定义,即
   ```C++
   cout << int;
   的原型是:
   ostream & operator << (int);
   //该原型表明函数会返回一个指向ostream对象的引用(即插入运算符的返回类型都是ostream &),这使得cout可以实现拼接输出,cout << "jlkjo" << 55;
   ```
13. <mark>`cout`输出会返回一个`ostream`对象(其实也就是`cout`对象)的引用,而`cin`会返回一个`istream`对象的引用.因此,可以实现在一行中链式输出和链式输入</mark>
14. `ostream`类为下面的指针类型定义了插入运算符函数:
   ![Alt text](markdwon图像集/image-22.png)
   <mark>因此,`cout`可以直接显示输出字符串(字符数组),而对于其它类型的指针(如`int`数组,它对应的指针类型是void*),`cout`不能直接通过输出数组名来输出数组值,此时只能打印数组名表示的地址</mark>
# 函数
1. <mark>函数传参实际上就是一个形参初始化的过程</mark>
2. `C++`中的隐式自动类型转换:
   ![Alt text](markdwon图像集/image-66.png)
3. <mark>在`C++`中，通过引用传递方式时并不会发生隐式的自动类型转换.引用传递是一种将参数传递给函数的方式,其主要特点是不会创建参数的副本,而是直接操作传递进来的对象.因此,引用传递的行为更接近于直接使用原始对象,不涉及隐式类型转换.按值传递有隐式的自动类型转换</mark>
4. <span style="color:red;">在函数参数传递时,可以将`const`数据或非`const`数据的地址赋给`const`指针,但只能将非`const`数据的地址赋给非`const`指针(这和`const`引用是一样的)</span>
5. 将指针作为函数参数来传递时,可以使用指向`const`的指针来保护数据
6. 将`const`用于指针有两种情形:
   * 让指针指向一个常量对象,这样可以防止使用该指针来修改所指向的值
   * 将指针本身声明为常量
7. 可以利用两个指针来表示元素区间:一个指针标识数组的开头,另一个指针标识数组的尾部(指向最后一个元素后面的指针)
8. <span style="color:red;">引用传递和指针传递·这两种方式都可以直接修改实参的值,如果需要防止无意修改内容,则可以用`const`;而按值传递自动会避免这种情况,因为按值传递会创建副本</span>-----------
9. 传递常规变量(非引用)时,函数将使用该变量的拷贝;但传递数组时,函数将使用原来的数组
10. `C++`对于返回值类型有限制,不能是数组,但可以是指针、结构和对象等(若需要返回数组,则可以利用指针)
11. 函数在执行返回语句后结束,如果函数包含多条返回语句,则函数在执行遇到的第一条返回语句后结束
12. 函数原型是一条语句，获取它的最简单方法是,复制函数定义的函数头,并添加分号
13. <mark>函数原型不需要提供变量名,有类型列表就可以了</mark>
14. <span style="color:red;">在函数形参(函数头或函数原型)中,如果用数组形式定义,有下面等价结论</span>
    ```C++
    函数头:
    int sum_arr(int arr[5], 5)<=>int sum_arr(int arr[], 5)<=>int sum_arr(int *arr, 5)
    函数原型:
    int sum_arr(int arr[5], 5);<=>int sum_arr(int arr[], 5);<=>int sum_arr(int [], 5);<=>int sum_arr(int *arr, 5);<=>int sum_arr(int *, 5);
    //实际上,C++中处理形参数组参数时是按照指针处理的,即读取的是这个数组的第一个元素的地址
    //从上面结果可知,形参中定义的数组size是没有用的(因此不能以为在形参数组定义中传入size,函数就能知道这个size了),因为实际上是处理的指针,即数组名,即该数组第一个元素的地址
    ```
15. 在`C++`中,当且仅当用于函数头或函数原型中,`int *arr`和`int arr[]`含义才是相同的
16. 二维数组的数组名也是一个地址,表示的是第一个元素(第一行数组)的地址,即<mark>二维数组名=数组指针</mark>
    ```C++
    *的优先级低于[]
    指针数组:是一个数组,其中每个元素都是指针
    int* pointerArray[5];//一个含有5个int*元素的数组,pointerArray数组中有5个指针元素
    数组指针:是一个指针,指向一个数组的指针
    int (*arrayPointer)[5];//指向一个由5个int组成的数组,arrayPointer是一个指针
    ```
17. C++中处理形参数组参数时是按照指针处理的,即读取的是这个数组的第一个元素的地址.因为二维数组名是一个数组指针,因此二维数组的形参可写为:
    ```C++
    eg:
    int sum(int (*ar2)[4], int size)//列数在数组形参中会定义, 这个size是行数,即二维数组中的元素个数(二维数组的元素个数其实是行数)
    而不是
    int sum(int* ar2[4], int size)
    ```
18. 当结构比较小时,可以按值传递结构
19. `C++`处理结构体的方式和基本类型完全相同,这意味着可以按值传递结构,并将其用作函数返回类型
20. 递归调用:先是前向递归,然后是反向回溯
21. 获取函数的地址=函数名
22. 实际上,函数名就是一个函数指针,它是指向该函数的地址
23. <span style="color:red;">在`C++`中,函数名被解释为函数指针.在大多数情况下,当使用函数名时,它会被隐式转换为指向函数的指针.因此,当使用函数名作为函数指针使用时,实际上已经使用了函数的地址,如`function()`.在大多数情况下,可以直接使用函数名,而不用取地址符`&`.但是,在某些情况下,例如当需要显式地指定函数指针类型时,或者在模板参数中使用函数指针时,可能需要使用取地址符`&`来获取函数的地址,以确保正确的类型匹配</span>
24. `&函数名`表示函数指针,而不是函数指针的指针
25. 声明指向某种数据类型的指针时,必须指定指针指向的类型,这意味着声明应指定函数的返回类型和参数列表,即:
    ```C++
    double pam(int);//声明一个函数
    double (*pf) (int);//pf为定义的函数指针
    pf = pam;
    //通常,要声明指向特定类型的函数的指针,可以直接利用函数的原型,将(*pf)替代函数名即可(注意不是用pf直接替代pam)
    ```
26. <mark>`C++`中有两种使用函数指针调用函数的方法:</mark>
    * 由于`pf`是函数指针,则`*pf`是函数,因此可以直接将`(*pf)`用作函数调用,即`double y = (*pf)(5)`
    * 由于函数名是指向该函数的地址,因此可以将函数指针直接用作函数调用,即`double y = pf(5)`
27. 函数指针数组:
    ```C++
    eg:
    const double * (*pa[3]) (const double *, int) = {f1, f2, f3};//*pa[3]是指针数组的定义形式,即pa是一个数组,其每个元素是一个指针
    ```
28. 函数数组指针:
    ```C++
    eg:
    const double * (*(*pd)[3]) (const double*, int) = &pa;//pa是24中的pa,(*pd)[3]是数组指针的定义形式,即pd是一个指针,指向一个包含3个元素的数组.建议使用auto
    auto pd = &pa;//pa表示函数指针数组,即数组名pa是指向函数指针的指针,因此指向此数组的指针就是&pa.使用auto可以使变量更具初始化表达式的类型推断变量的类型,而不需要我们显示声明类型
    ```
29. <span style="color:red;">`pa`(数组名)和`&pa`的区别:`pa`大多数情况表示数组第一个元素的地址,即`pa=&pa[0]`.但`&pa`是整个数组的地址.从数字上来说,`pa`和`&pa`的值相同,但它们类型不同.一个差别是,`pa+1`为数组下一个元素的地址,而`&pa+1`为数组`pa`后面一个12(假设数组大小为12)字节内存块的地址,另一个差别是,要得到第一个元素的值,只需对`pa`解除一次引用,但需对`&pa`解除两次引用</span>
30. 除了`auto`可以简化声明外,还可以利用`typedef`来创建类型别名,从而实现简化:
    ```C++
    eg:
    typedef const double *(*p_fun) (const doubkle*, int);//其实就是把函数指针的定义形式前面加一个typedef.定义了一个函数指针类型的别名
    p_fun p1 = f1;//p_fun为函数指针类型的别名,则p1为函数指针
    ```
31. 内联函数是`C++`为提高程序运行速度所做的一项改进,常规函数与内联函数的主要区别在于编译器如何将它们组合到程序中.常规函数是采用中断的方法将函数组合到程序中,即会来回跳跃(断点)并记录跳跃位置意味着以前使用函数时,需要一定的开销.`C++`的内联函数无需跳到另一个位置处执行代码,再跳回来,它会用内联代码(其实就是调用函数时对应的代码)替换函数调用的过程,相对于函数调用那句话在顺序执行时直接被替换成了对应的函数代码顺序执行.内联函数运行速度比常规函数快,但代价是需要占用更多内存
    ![Alt text](markdwon图像集/image-8.png)
32. 我们应该有选择的使用内联函数:如果执行函数代码的时间比处理函数调用机制的时间长,则节省的时间将只占整个过程的很小一部分,即此时内联函数作用不大;但若代码执行时间很短,则内联调用就很有用(内联函数只是改进了调用函数这个阶段的速度)
33. <mark>对于带参数列表的函数,必须从右向左添加默认值.也就是说,要为某个参数设置默认值,则必须为它右边的所有参数提供默认值</mark>
34. 实参按从左到右的顺序依次被赋给相应的形参,而不能跳过中间参数(认为中间参数设置为默认参数就可以只赋两端),赋给两边参数
    ```C++
    #include <iostream>
    // 函数声明中定义默认参数值
    void exampleFunction(int a, int b = 2, int c = 4);
    int main() {
        // 调用时提供所有实参
        exampleFunction(1, 3, 5);
        // 省略一个实参，使用默认值
        exampleFunction(1, 3);
        // 省略两个实参，使用默认值
        exampleFunction(1);
        //下面是不允许的
        exampleFunction(1, ,5);//如果要实现跳过中间参数,赋两端的,只能用函数重载(但是一般都会避免这种情形)
        return 0;
    }
    // 函数定义中不要重复定义默认参数值
    void exampleFunction(int a, int b, int c) {
        std::cout << "a: " << a << ", b: " << b << ", c: " << c << std::endl;
    }
    ```
35. <span style="color:red;">要实现函数默认参数,只需在原型中指定默认值,而函数定义的函数头不要显示写默认值.在`C++`中，函数的默认参数值应该定义在函数的声明中，而不是在函数的定义中</span>
36. 函数重载指的是可以有多个同名的函数,因此对名称进行了重载
37. 函数的参数列表<=>函数特征标
38. 如果两个函数的参数数目和类型相同,同时参数的排列顺序也相同,则它们的特征标相同(变量名无关紧要)
39. `C++`允许定义名称相同的函数,条件是它们的特征标不同(函数重载基本原则是参数数量、类型或顺序有所不同)
    ![Alt text](markdwon图像集/image-9.png)
40. 编译器在检查特征标时,将把类型引用和类型本身视为同一个特征标(意思是加个`&`不会改变特征标)
41. <span style="color:red;">在`C++`中,参数`char`到`const char`不算函数重载,因为编译器把它们两个视为相同类型的参数;但是参数`char*`到`const char*`算函数重载</span>
42. 函数模板是通用的函数描述,它们使用泛型来定义函数,其中的泛型可用具体的类型替换.通过将类型作为参数传递给模板,可使编译器生成该类型的函数
```C++
eg:
函数模板定义:
template <typename AnyType>
void Swap(AnyType &a, AnyType &b){
    AnyType temp;
    temp = a;
    a = b;
    b = temp;
}
//关键字template和typename是必需的,必须使用尖括号.类型名可以任意选择(这里为AnyType),可以是T
函数模板声明:
template <typename AnyType>
void Swap(AnyType &a, AnyType &b);
```
1.  函数模板并不创建任何函数,而只是告诉编译器如何定义函数
2.  `void`函数可以隐藏`return`
# 引用
1. `C/C++`都使用`&`来取地址
2. 引用一般用在函数中
3. 引用是一种允许使用一个已存在对象的别名的机制,引用变量提供了对同一内存位置的另一种访问方式,因此修改一个变量会影响另一个变量：
   ```C++
   1. 引用的声明和初始化:
   int b = 42;
   int &a = b;
   2. 修改引用变量会修改原始变量
   3. 引用作为函数形参
   ```
4. <mark>引用必须在声明时进行初始化,不能先声明再初始化.引用在声明时必须指定引用的类型</mark>
5. 引用变量和其它变量实际上没什么区别,加一个`&`只是表示它是引用变量.因此可以直接将其它变量(非引用变量)赋值给引用变量,而不是像指针那样只能将指针(地址)赋值给指针变量
6. `int`是整数类型,`int &`是整数引用类型
7. 引用经常被用作函数参数,使得函数中的变量名成为调用程序中的变量的别名,这种传递参数的方法称为按引用传递.
   ```C++
   引用传递格式:
   typename func(typename &variable,...)
   ```
8. <mark>若某函数有`const`引用形参,那么不能在函数内部修改引用形参的值,否则会报错</mark>  
9. `&`为左值引用,`&&`为右值引用(右值引用是指向右值的引用)
   ```s
   左值:左值参数是可被引用的数据对象,如:变量、数组元素、结构成员、引用和解除引用的指针.可以出现在赋值左侧.左值在表达式(如赋值表达式)结束后依然存在、可以被取地址的对象
   eg:
   int x = 42;//x是左值,42是右值
   右值:字面常量,如123等(字符常量不算)和包含多项的表达式,右值在表达式结束后就要被销毁,可以出现在赋值右侧,右值不能被取地址
   eg:
   int x = 2 + 3;//2+3是右值
   int && x = 6;//6是右值
   ```
10. <mark>当前`C++`中只有形参为`const`引用时,在实参和引用形参不匹配时才会生成临时变量,否则就会报错(即形参不是`const`时,形参和实参不匹配(包括了类型不匹配)就会报错)</mark>
11. <mark>如果引用参数为`const`,则编译器在下面两种情况会生成临时变量,即此时不会报错:</mark>
    ```s
    1. 实参的类型正确,但不是左值(此时实参可以为右值,如表达式)
    2. 实参类型不正确,但可以转换为正确的类型(这不是隐式自动类型转换)
    ```
    ```C++
      eg:
      int func(int& x){
         x = 5;
         return x;
      }
      int func(int& x);
      int main(){
      float i = 8.0;
      int k;
      k = func(i);
      cout << k << endl;
      return 0;
      }
      //这会报错,因为对于引用传递在非const引用参数时,就算是实参和形参数据类型不匹配也会报错(因为在引用传递中是没有隐式自动类型转换的(按值传递有),因此数据类型不匹配理论是要创建临时变量的,而非const不能创建临时变量,所以报错)
      eg:
      int func(const int& x){
         x = 5;
         return x;
      }
      int func(const int& x);
      int main(){
      float i = 8.0;
      int k;
      k = func(i);
      cout << k << endl;
      return 0;
      }
      //输出:5
    ```
    在引用传递里面,若不匹配就需要临时变量,而`C++`只允许`const`引用参数才能创建临时变量,而非`const`引用参数不能创建临时变量
12. 引用参数声明为`const`的好处:
    ```s
    * 使用const可以避免无意中修改数据的编程错误,此时改值就会报错
    * 使用const使函数能够处理const和非const实参,否则只能接受非const数据
    * 使用const引用使函数能够正确生成并使用临时变量
    ```
13. 右值引用
    ![Alt text](markdwon图像集/image-33.png)
14. 使用结构引用参数的方式与使用基本变量引用相同,只需在声明结构参数时使用引用运算符`&`即可
15. 传统返回机制与按值传递函数参数类似,这个返回(`return`)值被复制到一个临时位置
16. <span style="color:red;">引用返回和指针返回是不会复制到临时位置,既不会产生临时变量(除了某些特殊情况,如引用传递中利用`const`左值引用时的类型不匹配),此时效率更高;但按值传递会产生临时变量,即产生参数副本</span>
17. 返回引用时最重要的一点是:应避免返回函数终止时不再存在的内在单元引用,如:
    ![Alt text](markdwon图像集/image-77.png)(×),该函数返回的一个指向临时变量的引用,这个变量在函数运行完毕后就不再存在
18. 常规(非引用)返回类型是右值
19. 使得能够将特性从一个类传递给另一个类的语言特性被称为继承
20. 基类(如`ostream`),派生类(如`ofstream`)
21. 基类引用可以指向派生类对象,而无需进行强制类型转换,如:参数类型为`ostream &`的函数可以接受`ofstream`对象作为参数
22. 使用引用参数的主要原因：
    ![Alt text](markdwon图像集/image-88.png)
23. 使用引用的基本指导方针:
   * 对于使用传递的值而不修改的函数时:
    ![Alt text](markdwon图像集/image-99.png)
   * 对于修改调用函数中数据的函数时:
     ![Alt text](markdwon图像集/image-110.png)
24. `C++`中内置数据类型不是类,而是语言的基本构造块之一
# auto关键字
1. 用于声明变量时让编译器自动推断其类型,使得代码更灵活、可读性更好
   ```C++
   eg:
   auto variable_name = value;//编译器会根据初始化表达式(value,赋值等式的右端)的类型来推到变量variable_name的类型
   ```
2. `auto`在处理模板、迭代器和复杂的类型非常有用:
   ```C++
   eg:
   std::vector<int> num = ...;
   for(auto i = num.begin(); i <= num.end(); i++)
   ```
# 匿名函数
1. 语法形式:
   ```C++
   1. [capture-list](parameter-list)->return-type{function-body};
   2. [capture-list](parameter-list){function-body};//编译器可以自动推断返回值类型
   //变量捕获(方括号的部分,可以指定外部变量):让匿名函数可以访问(按值捕获)甚至修改(按引用捕获)函数外部的变量;按值捕获时在函数内部修改外部变量编译器会报错;
   []:不捕获任何变量
   [&]:捕获外部作用域的所有变量,并且是按引用捕获
   [=]:捕获外部作用域的所有变量,并且是按值捕获
   auto f = [](int i){return ...};
   f(10);//此时f就是这个匿名函数的函数名,f此时就像正常函数一样可以直接调用了
   ```
2. 匿名函数格式:`[capture](parameters) ->return-type{//函数体}`
3. 匿名函数若没有参数,则可以省略`()`,即`[]{...}`
4. 当函数主体只有`return`或者返回为`void`,那么`->return-type`可以被省略
5. 在线程池(线程数组)中添加线程时可以直接使用`lambda`表达式:
   ```C++
   threads.emplace_back([this](){
      //函数体
   }
   //threads是一个元素为std::thread的数组,因此这个lambda函数进来会调用thread的构造函数默认构造一个thread变量,而这个thread线程的入口函数就是这个lambda表达式
   ```
6. <span style="color:red;">匿名函数表达式中捕获的对象必须是可复制或可移动的,然而`std::packaged_task`对象本身是不可复制或移动的,但它所包装的任务函数理论上移动是安全的,因此我们可以通过`std::move`将`std::packaged_task`对象转换为可移动</span>
# 命名空间
1. 变量对程序而言可见的范围被称为作用域
2. 组织编写程序的策略:
   ```s
   头文件:包含结构声明和使用这些结构的函数的原型
   源代码文件:包含与结构有关的函数的代码(other.cpp)
   源代码文件:包含调用与结构相关的函数的带啊吗(main.cpp)
   ```
3. 头文件常包含的内容:
   ![Alt text](markdwon图像集/image-11.png)
4. <mark>`" "`文件名包含在双引号中,则编译器将首先查找当前的工作目录或源代码目录;如果没找到,则在标准位置查找.`< >`文件名若包含在尖括号中,则编译器将在存储标准头文件的主句系统的文件系统中查找</mark>
5. 自动变量:函数中不加关键字`static`声明的编译系统都视为自动变量,形参+局部变量.`C++`中将自动变量存储在栈中
6. 命名空间的定义:
   ```C++
   namespace namespace_name{
    ...
   }
   ```
7. 访问命名空间中名称的方法:<mark>作用域解析运算符`::`</mark>,`std::cout`,即叫做使用`std`名称限定`cout`
8. `C++`中提供了`using`声明和`using`编译(关键字`using namespace`)两种简化命名空间使用的方法
   ```C++
   eg:
   using std::cout;//using声明,仅使特定的标识符可用
   using namespace std;//using编译,使整个命名空间都可用
   ```
9.  `using`编译指令和`using`声明增加了名称冲突的可能性
10. 编译器不允许同时使用两个`using`声明
11. <span style="color:red;">命名空间的使用原则:</span>
    ```C++
    1. 命名空间只能全局范围内定义,不能在局部定义命名空间<=>命名空间可以是全局的,也可以位于另一个命名空间中,但不能位于代码块({}花括号内部叫代码块,包括main()也算)中
    2. 命名空间内可以存放变量和函数
    3. 命名空间可以嵌套
    4. 命名空间是开放的,可以随时加入新的成员
        eg:
        namespace A{
            int a=10;
        }
        ...
        namespace A{
            int c=20;
        }//这是添加不是覆盖
    5. 命名空间中的函数可以在命名空间外定义
        eg:
        namespace A{
            int a=10;
            void func();//还是需要内部声明
        }
        void func(){
            ...
        }
    6. 无名命名空间,意味着命名空间中的标识符只能在本文件内访问,相当于给标识符加了static
    ```
# 链表
1. 链表是一种通过指针串联在一起的线性结构,每个节点由两部分组成,一个是数据域一个是指针域(存放指向下一个节点的指针),最后一个节点的指针域指向`null`
2. 双链表:
   ![](Cpp基础知识图片集/2024-03-04-09-56-20.png)
3. 循环链表:
   ![](Cpp基础知识图片集/2024-03-04-09-57-13.png)
4. 数组是在内存中是连续分布的,但是链表在内存中不是连续分布的
5. 单链表的定义:
   ```C++
   struct ListNode{
      int val;
      ListNode *next;
      ListNode(int x):val(x), next(NULL){}//节点的构造函数
   }
   ```
6. 通过自己定义构造函数初始化节点和使用默认构造函数初始化节点:
   ```C++
   1. 
   ListNode *head=new ListNode(5);//在堆上分配链表节点,data初始化为5
   2. 
   ListNode *head=new ListNode();  
   head->val=5;
   ``` 
7. 在`C++`中,类和结构体都可以用来构建链表节点,它们的主要区别在于成员默认的访问权限(类的成员默认访问权限是`private`;结构体相反)以及默认的继承方式
# 函数模板
1. 在函数模板中,当使用右值引用作为模板参数时(`F&&`),可以根据实参的类型来推导出参数类型是左值引用还是右值引用,此时可以被称为"万能引用"
2. 留出具体执行任务函数的接口(即函数内容是不定的),写一个函数模板:
   ```C++
   std::function<void()> task;
   template<class F, class... Args>//不用打分号
   void function_interface(F&& f, Args&&... args){//f是要调用的函数地址(函数名),args是参数;...表示可以有任意的参数个数
      task = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
      task();//运行这个任务函数
   }
   ```
3. 在`C++11`之前函数模板的返回类型必须显示指定,即:`typename add(F&&f, Args&&... args)`.在`C++11`中引入了<mark>`auto`关键字和尾返回类型语法</mark>,即:`auto add(F&&f, Args&&... args)->decltype(f(args...))`
4. 2.的完整例子:
   ```C++
   class Test{
   private:
      std::function<void()> task;
   public:
      template<class F, class... Args>//不用打分号
      void function_interface(F&& f, Args&&... args){//f是要调用的函数地址(函数名),args是参数;...表示可以有任意的参数个数
         task = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
         task();
      }
   };

   void func(int i){
      std::cout << I << std::endl;
   }

   int main(){
      Test A;
      A.function_interface(func, 2);
      return 0;
   }
   ```
5. <mark>对于函数模板,调用时可以省略尖括号`<>`,编译器会根据传入的参数类型推断模板参数的类型;然而在类模板中,由于类型推断可能会更加复杂,因此在实例化类模板时,通常需要显式指定尖括号`<>`并提供模板参数类型:</mark>
   ```C++
   1. 函数模板,调用时不需要尖括号
   template<typename T>
   T max(T a, T b) {
      return (a > b) ? a : b;
   }
   int main() {
      int result = max(3, 5); // 编译器推断为 max<int>(3, 5)
      double result2 = max(3.0, 5.0); // 编译器推断为 max<double>(3.0, 5.0)
      return 0;
   }
   2.
   类模板,调用时需要尖括号
   template<typename T>
   class MyClass {
   public:
      T value;
      MyClass(T val) : value(val) {}
   };

   int main() {
      MyClass<int> obj1(5); // 显式指定类型
      MyClass<double> obj2(3.14); // 显式指定类型
      // MyClass obj1(5); // 错误，需要显式指定类型
      return 0;
   }
   ```
# 类
1. `C++`中,类的成员变量可以在类的构造函数中初始化,也可以使用成员初始化列表来初始化(冒号实现初始化列表):
   ```C++
   1. 构造函数中初始化:
   #include <iostream>
   class MyClass {
   public:
      MyClass(int value) {
         // 在构造函数中初始化成员变量
         myInt = value;
      }
      void printValue() {
         std::cout << "myInt: " << myInt << std::endl;
      }
   private:
      int myInt;
   };
   int main() {
      MyClass obj(42);
      obj.printValue(); // 输出: myInt: 42
      return 0;
   }
   2. 初始化列表初始化:
   #include <iostream>
   class MyClass {
   public:
      // 使用成员初始化列表初始化成员变量
      MyClass(int value) : myInt(value) {}
      void printValue() {
         std::cout << "myInt: " << myInt << std::endl;
      }
   private:
      int myInt;
   };
   int main() {
      MyClass obj(42);
      obj.printValue(); // 输出: myInt: 42
      return 0;
   }
   ```
2. <span style="color:red;">`C++`中的类构造函数在创建对象时会被自动调用.构造函数是用来初始化对象的特殊成员函数,其名称和类名相同,没有返回类型,可以有返回参数也可以没有.当创建一个类的对象时,编译器会自动调用适当的构造函数来初始化对象的成员变量</span>:
   ```C++
   #include <iostream>
   class MyClass {
   public:
      // 无参构造函数
      MyClass() {
         std::cout << "无参构造函数被调用" << std::endl;
      }
      // 有参构造函数
      MyClass(int value) {
         std::cout << "有参构造函数被调用，参数为: " << value << std::endl;
      }
   };
   int main() {
      MyClass obj1;        // 调用无参构造函数
      MyClass obj2(42);    // 调用有参构造函数
      return 0;
   }
   ```
3. `C++`类的析构函数会在对象被销毁时自动调用.具体地说:
   ```C++
   1. 当对象超出其作用域时,析构函数会被自动调用
   2. 当对象是动态分配的,通过delete手动释放内存时析构函数会被调用
   ```
4. 类的构造函数只能在创建对象时调用一次
# nullptr
1. 在`C++`中,`nullptr`表示空指针常量,即空指针,可以用于任何指针类型的初始化、比较和赋值操作.`nullptr`取代了传统的`NULL`或`0`来表示空指针,具有更好的类型安全性和可读性.在链表中有时为了方便解题可以将空指针想做`head`的前一个节点,这样有时可以将`head`节点与其它节点使用相同的迭代公式(见`leetcode 206翻转链表`).总的来说,`nullptr`提供了一种更安全和更明确的方式来处理空指针,避免了与整数0的混淆
    
    