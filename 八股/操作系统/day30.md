1. `select()`、`poll()`、`epoll()`的对比:
   * `select`缺点：select() 检测数量有限制，最大值通常为 1024（bit）；每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
   * `poll`缺点：poll解决了select的检测文件描述符表上限的问题，但是另外两个问题还是有
   * `epoll`优点：epoll底层数据结构； 红黑树增删改综合效率高；epoll是基于事件通知而不是轮询，因此不需要遍历；epoll通过epoll_ctl添加文件描述符时是直接在内核中进行的，因此epoll不会每次调用时都从用户态到内核态进行拷贝
2. 我们编写的代码只是一个存储在硬盘的静态文件,通过编译、汇编、链接后就会生成二进制可执行文件,当我们运行这个可执行文件后,它会被装在到内存中,接着CPU会执行程序中的每一条指令,那么这个运行中的程序就是进程
3. 单核的CPU在某一个瞬间,只能运行一个进程.但在1秒钟期间,它可能会运行多个进程,这样就产生并行的错觉,实际上这是并发
4. 进程状态有:创建状态、就绪状态、运行状态、阻塞状态、结束状态,完整的进程状态变迁过程:
   ![](../markdown图像集/2025-05-17-09-46-56.png)
   阻塞状态的进程可能会占用着物理内存,这不是我们希望的,因此通常会把阻塞状态的进程的物理内存空间换出到硬盘,等需要再次运行的时候,再从硬盘换入到物理内存就行
5. 在操作系统中,是用进程控制块PCB数据结构来描述进程的,PCB是进程存在的唯一标识,PCB包含:进程描述信息(进程标识符、用户标识符)、进程控制和管理信息(进程当前状态、进程优先级)、资源分配清单、CPU相关信息
6. PCB是通过链表的方式组织的,把具有相同状态的进程链在一起,组成各种队列,如:就绪队列、阻塞队列
   ![](../markdown图像集/2025-05-17-09-53-46.png)
7. 当进程被阻塞后,它只能由另一个进程唤醒
8. CPU上下文切换就是先把前一个任务的CPU上下文(CPU寄存器和程序计数器)保存起来,然后加载新任务的上下文到这些寄存器和程序计数器,最后再跳转到程序计数器所指的新位置,运行新任务
   ![](../markdown图像集/2025-05-17-10-04-47.png)
9.  CPU上下文切换:进程上下文切换、线程上下文切换和中断上下文切换
10. 进程的缺点:维护进程的系统开销较大,如创建进程时,分配资源、建立PCB;终止进程时,回收资源、撤销PCB;进程切换时,保存当前进程的状态信息
11. 线程的优点:
    * 一个进程中可以同时存在多个线程
    * 各个线程之间可以并行执行
    * 各个线程之间可以共享进程空间,因此切换更快
12. 线程的缺点:当进程中的一个线程崩溃时,会导致其所属进程的所有线程崩溃
13. 线程的上下文切换:
    * 当两个线程不是属于同一个进程,则切换的过程就跟进程上下文切换一样
    * 当两个线程是属于同一个进程,因为虚拟内存是共享的,所以在切换时,虚拟内存这些资源就保持不动,只需要切换线程的私有数据、寄存器等不共享的数据