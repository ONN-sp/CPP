1. `C++`的多态怎么实现:
   * 函数模板+重载(编译时多态)
   ```C++
   // 模板函数，用于打印不同类型的数据
   template <typename T>
   void print(const T& value) {
      cout << value << endl;
   }
   // 重载模板函数，用于打印字符串
   void print(const string& value) {
      cout << "String: " << value << endl;
   }
   // 重载模板函数，用于打印布尔值
   void print(bool value) {
      cout << (value ? "True" : "False") << endl;
   } 
   ```
   * 虚函数+继承(运行时多态)
2. 对于运行时多态一般是用基类指针来访问的,即基类指针主要用于多态场景(注意:不能用基类指针来访问子类新增的成员(变量或函数),必须基类也要有).如:
   ```C++
   // 基类
   class Animal {
   public:
      virtual void makeSound() {
         cout << "动物发出声音" << endl;
      }
   };
   // 子类1
   class Dog : public Animal {
   public:
      void makeSound() override {
         cout << "汪汪汪" << endl;
      }
   };
   // 子类2
   class Cat : public Animal {
   public:
      void makeSound() override {
         cout << "喵喵喵" << endl;
      }
   };
   int main() {
      Animal* animal1 = new Dog();
      Animal* animal2 = new Cat();
      animal1->makeSound(); // 输出 "汪汪汪"
      animal2->makeSound(); // 输出 "喵喵喵"
      delete animal1;
      delete animal2;
      return 0;
   }
   ```
3. `C++`中,类实例化后的对象主要为非静态成员变量分配内存,而静态成员变量(静态存储区)和成员函数(代码区).非静态成员变量存储在对象的内存空间中
4. 多态的底层原理:
   * 在编译阶段,编译器在发现基类中有虚函数时,会自动为每个含有虚函数的类生成一份虚表(虚函数表),该表是一个一维数组,虚表里保存了虚函数的入口地址.如果一个类没有虚函数,那么通常它不会有虚表和虚表指针(除了当前类为一个有着虚函数的基类派生而来的情况,此时这个当前的派生类也会有虚表和虚表指针)
   * 编译器会在每个对象的前四个字节(32位系统)中保存一个虚表指针(要证明它确实存在可以利用`sizeof(类对象)`)(虚表指针存在每个对象的开头4字节中),执行对象所属类的虚表.在构造时(注意:虚表指针是在运行时类实例化时才会有,它是在类的构造函数中创建生成的),根据对象的类型去初始化虚表指针`vptr`,从而让`vptr`指向正确的虚表,从而在调用虚函数时,能找到正确的函数(虚表指针是类的非静态成员变量),虚表指针是通过`this`指针访问的
   * 派生类在编译阶段会构建自己的虚表,虚表中包含了对基类的重写(`override`),也包含了自己新增的虚函数.在派生类定义对象时程序运行会自动调用构造函数,在构造函数中对虚表初始化.在构造子类对象时,会先调用父类的构造函数.此时,编译器只看到了父类,并为父类对象初始化虚表指针,令它指向父类的虚表;当调用子类的构造函数时,为子类对象初始化虚表指针,令它指向子类的虚表
   * 当派生类对基类的虚函数没有重写时,派生类的虚表指针指向的是基类的虚表;当派生类对基类的虚函数重写时,派生类的虚表指针指向的是自身的虚表;当派生类中有自己的虚函数时,会在自己的虚表中将此虚函数地址添加在后面，这样指向派生类的基类指针在运行时,就可以根据派生类对虚函数重写情况动态的进行调用,从而实现运行时多态 
5. 一个类的虚函数表只会有一份,就算这个类实例了很多对象,它们也是共享一个虚表的
6. 构造函数不能是虚函数:
   * 创建一个对象时需要确定对象的类型,而虚函数是在运行时动态确定其类型的.在构造一个对象时,由于对象还未创建成功,编译器无法知道对象的实际类型
   * 虚函数对应一个虚函数表,类中存储一个虚表指针指向这个虚函数表.如果构造函数是虚函数,就需要通过虚表指针调用,可是对象没有初始化就没有虚表指针,无法找到虚函数表,所以构造函数不能是虚函数
   * 虚函数的作用在于通过父类的指针或引用来调用它的时候能够变成调用子类的那个成员函数(即基类指针/引用的使用),而构造函数是在创建对象时自动调用的,不可能通过父类或者用去调用,因此就规定构造函数不能是虚函数
7. `C++`中虚函数表位于可执行文件的只读数据段,也就是`C++`内存模型的常量区;而虚函数位于代码段
8. 函数模板和类模板的特例化:
   * 函数模板特例化:必须为原函数模板的每个模板参数都提供实参,且使用关键字`template`后跟一个空尖括号对`<>`,表明将原模版的所有模板参数提供实参.特例化的本质是实例化一个模板,而不是重载它.模板及其特例化版本应该声明在同一个头文件中,且所有同名模板的声明应该放在前面,后面放特例化版本
   * 类模板特例化:在类中,可以进行完全特例化也可以部分特例化,仍然是使用`template<>`
9.  构造函数可以重载,析构函数不能重载,一个类只能有一个析构函数,且不能指定参数
10. `inline`同`register`(这个关键字请求编译器尽可能的将变量存在`CPU`内部寄存器中,而不是通过内存寻址访问,以提高效率)一样,只是个建议,编译器并不一定真正的内联.将构造函数和析构函数声明为`inline`是没有意义的,即编译器并不真正对声明为`inline`的构造和析构函数进行内联操作,因为编译器会在构造和析构函数中添加额外的操作(申请/释放内存,构造/析构对象等),致使构造函数/析构函数并不像看上去的那么精简.虚函数只有在对象本身调用虚函数时而不是多态情况中时声明为`inline`才会内联展开
11. 内联函数是在编译阶段进行替换展开的
12. 编译器会对函数模板进行两次编译:在声明的地方对模板代码本身进行编译(头文件中),在调用的地方对参数替换后的代码进行编译
13. `C++`中基类采用`virtual`虚析构函数是为了防止内存泄漏
14. 析构函数的作用:与构造函数的作用相反,用于撤销对象的一些特殊任务处理,可以是释放对象分配的内存空间.析构函数没有参数,也没有返回值,而且不能重载,在一个类中只能有一个析构函数
15. 在`C++`中,不提倡在构造函数和析构函数中调用虚函数(从语法上讲是没错的)
    * 父类对象会在子类之前进行构造,此时子类部分的数据成员还未初始化,因此调用子类的虚函数是不安全的
    * 析构函数是用来销毁一个对象的,在销毁一个对象时,先调用子类的析构函数,然后再调用基类的析构函数.所以在调用基类的析构函数时,派生类对象的数据成员已经销毁,这个时候再调用子类的虚函数是没有任何意义的
16. `C++`可以定义空类,空类大小为1字节
17. 成员函数和普通函数的区别
    * 成员函数是定义在类内部的函数，它属于类的一部分，与类的对象相关联;普通函数是在类外部定义的独立函数，不属于任何类
    * 成员函数是类的组成部分，能够直接访问类中的其他成员（包括私有成员），这体现了封装的特点;普通函数与类没有直接的从属关系，不能直接访问类的成员，除非通过对象或者友元等方式
    * 成员函数的调用会隐式地传递一个指向调用该函数的对象的指针(`this`指针),通过这个指针可以访问对象的数据成员和成员函数
18. `C++`的类的成员函数的调用会隐式地传递一个指向调用该函数的对象的指针(`this`指针).在编译器内部,非静态成员函数确实被改写成一个普通函数,其第一形参就是这个`this`指针
19. `C++`的类中,如果没有显式地定义任何构造函数,编译器会自动生成一个默认构造函数(无参构造函数);一旦类中定义了至少一个构造函数,编译器将不再提供默认构造函数
20. `C++`中,子类必须调用父类的构造函数:
    * 如果父类有默认构造函数,就不用在子类中显式初始化父类的构造函数,因为编译器会自动调用它们来初始化父类对象
    * 若父类显式定义了构造函数,那么子类构造函数就必须显式调用父类的构造函数 
21. `C++`的多继承:运行一个类继承多个基类的属性和方法.构造函数的执行顺序是按照继承列表中基类出现的顺序进行的,而析构函数的执行顺序则与构造函数相反
22. 在多继承情况下,派生类继承了多个基类,这些基类中可能包含同名的成员(成员函数或成员变量).当在派生类中使用这些同名成员时,编译器无法确定应该使用哪一个基类中的成员,从而产生歧义,即二义性
   ```C++
       // 基类1
   class Base1 {
   public:
      void show() {
         cout << "Base1 show" << endl;
      }
   };
   // 基类2
   class Base2 {
   public:
      void show() {
         cout << "Base2 show" << endl;
      }
   };
   // 派生类继承自Base1和Base2
   class Derived : public Base1, public Base2 {
   public:
      void display() {
         show();// 产生二义性 
      }
   };
   int main() {
      Derived d;
      d.display(); 
      return 0;
   }
   ```
23. 菱形继承(菱形继承即是一个类通过多继承继承了多个基类,而这些基类又有一个共同的基类,即祖父类)会出现二义性问题:如果祖父类中有一些成员(成员函数或成员变量),那么当两个父类都继承自祖父类时,派生类会分别从两个父类继承祖父类的成员,导致祖父类的成员在派生子类中出现了两次(因为祖父类的成员在两个父类中有两个副本),当在派生子类中访问祖父类的成员时,编译器无法确定应该访问从哪一个中间父类继承来的祖父类的成员,从而产生二义性
    ![](../markdown图像集/2025-05-02-21-46-06.png)
24. 解决二义性的办法:
   * 使用域解析符明确指定要调用的基类的成员函数
   ```C++
   // 基类1
   class Base1 {
   public:
      void show() {
         cout << "Base1 show" << endl;
      }
   };
   // 基类2
   class Base2 {
   public:
      void show() {
         cout << "Base2 show" << endl;
      }
   };
   // 派生类继承自Base1和Base2
   class Derived : public Base1, public Base2 {
   public:
      void display() {
         Base1::show(); // 明确调用Base1的show函数
         Base2::show(); // 明确调用Base2的show函数
      }
   };
   int main() {
      Derived d;
      d.display(); // 输出 Base1 show 和 Base2 show
      return 0;
   } 
   ```
   * 在派生子类中重写该成员,明确指定要调用的基类的成员函数
   ```C++
   // 基类1
   class Base1 {
   public:
      void show() {
         cout << "Base1 show" << endl;
      }
   };
   // 基类2
   class Base2 {
   public:
      void show() {
         cout << "Base2 show" << endl;
      }
   };
   // 派生类继承自Base1和Base2
   class Derived : public Base1, public Base2 {
   public:
      void show() {
         Base1::show(); // 重写show函数，调用Base1的show函数
      }
   };
   int main() {
      Derived d;
      d.show(); // 调用Derived类中的show函数，进而调用Base1的show函数
      return 0;
   } 
   ```
   * 菱形继承中的二义性可以通过虚继承解决:虚继承确保了两个父类只有一个祖父类的成员副本,而不是多个.当使用虚继承时,编译器会为每个虚继承的基类创建一个单独的继承路径,并在派生类中引入一个指向共同基类的指针,即无论通过哪个中间父类访问共同的祖父类的成员,都会指向同一个成员副本
   ```C++
   // 祖父类
   class TopBase {
   public:
      void show() {
         cout << "TopBase show" << endl;
      }
   };
   // 基类1虚继承自TopBase
   class Base1 : virtual public TopBase {
   };
   // 基类2虚继承自TopBase
   class Base2 : virtual public TopBase {
   };
   // 派生类继承自Base1和Base2
   class Derived : public Base1, public Base2 {
   };
   int main() {
      Derived d;
      d.show(); // 正确：调用TopBase的show函数，没有二义性
      return 0;
   } 
   ```
25. 虚继承(虚继承=以`virtual`方式继承某个基类;这个基类在继承体系中就称为“虚基类”)情况下,无论基类被继承多少次,只会存在一个实体.子类通过增加某种指针`bptr`来访问这个基类.如果既存在`vptr`(虚表指针)又存在`bptr`,某些编译器会优先,合并为一个指针
26. 构造函数、析构函数的执行顺序:
   * 构造函数
      - 基类构造函数.如果有多个基类,则构造函数的调用顺序是某类在类派生表中出现的顺序,而不是它们的成员初始化表中的顺序
      - 成员类对象构造函数.如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序,而不是它们出现在成员初始化表中的顺序
      - 派生类构造函数
   * 析构函数(在派生类中调用析构函数)
      - 调用派生类的析构函数
      - 调用成员类对象的析构函数
      - 调用基类的析构函数
27. `C++`只会析构已经完成的对象,对象只有在其构造函数执行完毕才算是完全构造妥当.在构造函数中发生异常,控制权转出构造函数之外.因此,在对象B的构造函数中发生异常,对象B的析构函数不会被调用,因此会造成内存泄漏.此时为了解决发生异常时的内存泄漏就引入了`auto_ptr`
28. 类什么时候会析构:
    * 对象生命周期结束,被销毁时
    * `delete`指向对象的指针时,或`delete`指向对象的基类类型指针(前提是基类析构函数是虚函数)
    * 对象i是对象o的成员,o的析构函数被调用时,对象i的析构函数也被调用
29. 构造函数的关键字
    * `default`:可以显式要求编译器生成默认构造函数,即就算自己定义了带参构造函数,此类中也会有默认的无参构造函数,防止在调用时相关构造函数类型没有定义而报错
    * `delete`:可以删除构造函数、赋值运算符函数等(比如单例模式中)
    * `=0`:纯虚函数      
30. 构造函数、拷贝构造函数和赋值运算符的区别
    * 构造函数:对象不存在,没用别的对象初始化,在创建一个新的对象时调用构造函数
    * 拷贝构造函数:对象不存在,但是使用别的已经存在的对象进行初始化(1.以一个已经初始化的对象为构造函数参数去构建新对象时;2.以一个已经初始化的对象去赋值初始化另一个对象时) 
    * 赋值运算符:对象存在,用别的对象给它赋值,这属于重载`=`的范畴,`=`两侧的对象都是已存在的,不然是拷贝构造.如
    ```C++
    class A {
      public:
         A() {}
         A(const A& a) {}
         A& operator=(A& a){}
         ~A(){}
    };
    int main() {
      A a1;// 调用构造函数
      A a2=a1;// 调用拷贝构造函数
      a2 = a1;// 调用赋值运算符
      return 0;
    } 
    ```
31. 拷贝构造函数和赋值运算符的区别
    * 拷贝构造函数是函数,赋值运算符是运算符重载
    * 拷贝构造函数会生成新的类对象,赋值运算符不能
    * 拷贝构造函数用于创建新对象并初始化为已有对象的副本,赋值运算符用于将一个对象的值赋给已存在的对象
    * 默认的拷贝构造函数和赋值运算符都是浅拷贝,都可以利用自定义实现来实现深拷贝