1. `ip`地址确定是哪个计算机，端口号用来确定是哪个进程
2. 网络通信的主体部分是：客户端、服务器.在客户端和服务器通信的时候主要涉及:IP、端口、通信数据
3. socket其实就是个代码库或接口层，它介于内核和应用程序之间，提供了一些高度封装过的接口，让我们使用内核网络的传输功能。socket可以形象的想做一个应用程序的"插座"
4. 在网络通信中,"socket"具体指的是一种编程接口，用于实现网络通信。<mark>它是一种抽象概念，代表一个端点，能够通过网络与其它应用程序进行通信。这个端点可以是服务端或客户端，在TCP/IP协议中，套接字通常由IP地址和端口号来标识</mark>。在编程中，通过套接字可以创建、配置、连接、发送和接收数据，从而实现网络通信
5. `uname -a`查看内核/操作系统/CPU
6. `exit(0)`:C++中提前退出程序,不管是局部函数还是什么,只要遇到就会完全退出main主程序
# 字节序
1. 目前各种计算机中通常采用的字节存储机制主要有两种:Big-Endian(大端)和Little-Endian(小端)
2. 大端-网络字节序(网络通信时用的大端),小端-主机字节序
3. 小端:数据的低位字节存储到内存的低地址位,数据的高位字节存储到内存的高地址位.PC机默认是小端;大端则相反.<mark>套接字通信过程中操作的数据都是大端存储的,包括:接收/发送的数据、IP地址、端口</mark>
4. 大小端转换函数
   ```C++
   htons();
   htonl();
   ntohl();
   ntohs();
   ```
# TCP
1. TCP是一个面向连接的(三次握手)、安全的、流式传输协议，这是一个传输层协议
2. TCP连接：三次握手，TCP断开：四次挥手
3. ![](2024-02-04-13-11-19.png)
4. 在网络通信中,"操作是阻塞的"指的是当程序执行一个网络操作(比如send(),recv())时，程序会被阻塞，直到这个操作完成或者出现错误，这意味着，在执行网络操作期间，程序无法执行其它任务，它会一直等待直到网络操作完成
5. 服务器端通信流程:
   ```C++
   1. 创建用于监听的套接字,这个套接字是一个文件描述符(检查有没有新的客户端来连接)
   int fd = socket();
   2. 将得到的监听文件描述符和本地的IP端口进绑定
   bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);//将sockfd与sockaddr结构体中的addr的IP和端口绑定
   3. 设置监听(成功之后才开始监听,即成功之后用于检查客户端连接的套接字才开始工作,监听的是客户端的连接)
   listen();
   4. 等待并接受客户端的连接请求(握手请求),建立新的连接,会得到一个新的文件描述符(通信的,第一步那个是监听的文件描述符),没有新连接(握手)请求就阻塞
   int fd2 = accept();//要建立多个连接请求,需要多个accept
   5. 通信,读写操作默认是阻塞的
   read();/recv();
   write();/send();
   6. 断开连接,关闭套接字
   close();//服务端调用一次就是挥手两次
   ```
6. 客户端通信流程:
   ```C++
   1. 创建一个通信的套接字,得到监听文件描述符
   int fd1 = socket();
   2. 连接服务器,需要知道服务器绑定的IP和端口(是客户端主动连接)
   connect();//客户端在调用connect()后会自动随机给客户端程序绑定一个未被占用的端口和此客户端的IP地址
   3. 通信
   read();/recv();
   write();/send();
   4. 断开连接
   close();
   ```
7. 
   ```C++
   struct sockaddr{
      sa_family_t sa_family;//4字节,地址族协议
      char sa_data[14];//port(2字节)+IP地址(4字节)+填充(8字节)
   }
   ```
8. 在同一台计算机上进行服务端-客户端通信测试时:
   ```s
   1. 
   服务端=127.0.0.1  客户端=本地局域网IP    
   #此时是不能通信的,服务端监听的地址是 127.0.0.1，表示仅接受来自本地的连接。因此，如果客户端尝试使用局域网IP地址连接，连接请求将被拒绝，导致连接失败
   2. 
   服务端=127.0.0.1  客户端=127.0.0.1#可以的
   3.
   服务端=本地局域网IP  客户端=本地局域网IP#可以的
   4.
   服务端=INADDR_ANY    客户端=本地局域网IP/127.0.0.1#都行
   ```
9. 在实际应用中,一般我们在服务端绑定端口的时候可以选择绑定到0.0.0.0(AINADDR_ANY),这样我的服务访问方就可以通过我的多个ip地址访问我的服务
10. 与n个客户端通信,那么服务端的通信文件描述符个数=n
