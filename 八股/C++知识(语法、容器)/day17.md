1. 什么是内存泄漏,怎么检测和避免?
   * 内存泄漏常是指堆内存泄漏.堆内存是指程序从堆中分配的,大小任意的内存块,使用完后必须显示释放的内存.应用程序一般使用`malloc、realloc、new`等函数从堆中分配内存,使用完后,程序必须负责相应的调用`free/delete`释放该内存块,否则就说这块内存泄漏了
   * 避免内存泄漏的方式:
    - 计数法:`new/malloc`就+1,`delete/free`就-1,最后不为0就是发生了泄漏
    - 一定要将基类的析构函数声明为虚函数
    - 对象数组的释放一定要有`delete []`
    - `new/delete`和`malloc/free`一定要成对出现
   * 检测工具:`Linux`下使用`Valgrind Memcheck`  
2. 为什么防止内存泄漏一定要将基类的析构函数声明为虚函数?
    `C++`中,基类指针可以指向派生类对象,如果基类的析构函数不是虚函数,当通过基类指针删除派生类对象时,只会调用基类的析构函数,而不会调用派生类的析构函数.这会导致派生类中分配的资源无法被正确释放,从而引发内存泄漏.(原因:如果析构函数不被声明为虚函数,则编译器实施静态绑定,在删除基类指针时,只会调用基类的析构函数而不调用派生类析构函数,从而导致内存泄漏。如果基类的析构函数是虚函数，派生类的析构函数会被正确调用)
3. 对象复用:对象复用本质是一种设计模式:`Flyweight`享元模式,通过将对象存储到"对象池"中实现对象的重复利用,这样可以避免多次创建重复对象的开销,节约系统资源
4. 零拷贝就是一种避免`CPU`将数据从一块内存拷贝到另一块内存的技术,零拷贝技术可以减少数据拷贝和共享总线操作的次数,`emplace_back`就是很好的体现了零拷贝技术,它是直接将插入的元素原地构造,不需要触发拷贝构造和移动构造.`Linux`中内核空间和用户空间的零拷贝函数:`sendfile()、splice()、mmap()`
5. `C++`的函数模板是在编译阶段解析和实例化的
6. 面向对象的三大特性
   * 继承:让某种类型对象获得另一个类型对象的属性和方法
   * 封装:将数据和代码捆绑在一起,避免外界干扰和不确定访问.也就是把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏.如:将公共的数据或方法用`public`修饰,而不希望被访问的数据或方法采用`private`
   * 多态:多态允许相同的操作在不同的对象上表现出不同的行为,分为编译时多态(静态多态)和运行时多态;函数重载和函数模板实现编译时多态,虚函数和继承实现运行时多态.多态的实现有两种方式:覆盖(子类重新定义父类的虚函数的做法)和重载(指允许存在多个同名函数,而这些函数的参数表不同)
7. `C++`为什么需要运行时多态(动态多态)?
   * 运行时多态允许程序在运行时根据对象的实际类型调用相应方法,而不是编译时决定,这样可以使代码更加灵活和通用
   * 接口的统一和抽象:通过定义一个基类接口,并在派生类中实现这些接口,可以将具体实现与接口分离,这使得代码更具可扩展性和可维护性
   * 代码的重用和扩展:运行时多态使得可以通过继承和虚函数来扩展已有的代码,而无需修改现有代码.新的实现直接通过继承基类和`override`虚函数就行
   * 实现细节的隐藏:运行时多态允许对象的具体实现对客户端代码保持隐藏
8. `C++`的四次强制类型转换
   * `static_cast`不能用于在不同类型的指针之间的转换,也不能用于整型和指针之间的相互转换,当然也不能用于不同类型的引用之间的转换,它只能用于风险低的转换,如整型和浮点型、字符型(基类数据类型之间的转换)之间的相互转换,不能保证安全性
   * `reinterpret_cast`用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换.转换时,实际执行的是逐个比特复制的操作(这种转换是不安全的,使用时要非常小心)
   * `const_cast`用于进行去除变量的`const`属性的一个转换
   * `dynamic_cast`用于将多态基类的指针或引用(多态基类指针是一个指向派生类对象的基类类型的指针)强制转换为其派生类的指针或引用(向下类型转换),而且能检查转换的安全性(与`reinterpret_cast`不同).对于不安全的指针转换,转换结果直接返回`NULL`指针
9. `C++`函数调用的压栈过程:当主函数调用到某个函数A时,编译器此时会将主函数的运行状态进行压栈;再将函数A的返回地址、A的参数从右到左、A函数定义变量依次压栈;在返回的时候会从栈顶依次弹出
10. `coredump`文件是程序由于异常或者`bug`在运行时异常退出或者终止,在一定的条件下生成的一个叫做`core`的文件,这个文件会记录程序在运行时的内存、寄存器状态、内存指针和函数堆栈信息等等.对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息.可以使用`gdb`对这个`core`文件进行调试
11. 谈谈移动构造函数
    * 拷贝构造函数是把对象A的内容复制一份到B中,即发生的是深拷贝.而移动构造函数设计的目的是为了避免新的空间的分配,降低构造的成本
    * 移动构造函数的参数和拷贝构造函数不同,拷贝构造函数的参数是一个左值引用,但是移动构造函数的参数是一个右值引用.意味着,移动构造函数的参数是一个右值或将亡值的引用.也就是说,只要用一个右值/将亡值初始化另一个对象时才会调用移动构造函数,`std::move()`将一个左值变成一个将亡值
12. `C++`中将临时变量作为返回值时的处理:临时变量在函数调用完毕时会销毁,但是对于其作为返回值时,返回值会通过值传递(编译器无返回值机制时,则会通过拷贝构造来处理返回值,即在函数内部创建一个临时对象,然后返回时调用拷贝构造函数,将临时对象的值拷贝到调用者的上下文中)或返回值机制(直接在调用者的上下文中构造返回值,而不是先创建一个临时对象)被正确传递到调用者的上下文中,确保调用者可以正常使用返回值
13. 如何获得结构成员相对于结构开头的字节偏移量:使用`<stddef.h>`头文件中的`offsetof`宏
14. 静态类型和动态类型,静态绑定和动态绑定
    * 静态类型:对象在声明时采用的类型,在编译器既已确定
    * 动态类型:通常是指一个指针或引用目前所指对象的类型,是在运行期决定的
    * 静态绑定:绑定的是静态类型,所对应的函数或属性依赖于对象的静态类型,发生在编译器
    * 动态绑定:绑定的是动态类型,所对应的函数或属性依赖于对象的动态类型,发生在运行期
    * 静态绑定和动态绑定的区别
      - 静态绑定发生在编译器,动态绑定发生在运行期
      - 对象的动态类型可以更改,但是静态类型无法更改
      - 要想实现多态,必须使用动态绑定
      - 在继承体系中只有虚函数使用的是动态绑定,其它全部是静态绑定
    * 引用可以实现动态绑定
15. 全局变量和局部变量的区别
    * 生命周期不同:全局变量随主程序创建而创建,随主程序销毁而销毁;局部变量在局部函数内部,甚至局部循环体等内部存在,退出就不存在
    * 使用方式不同:通过声明后全局变量在程序的各个部分都可以用到;局部变量分配在堆栈区,只能局部用
    * 操作系统和编译器通过内存分配的位置可以区分两者,全局变量分配在数据段`.data`并且在程序开始运行时被加载,局部变量则分配在堆栈里面
16. 判断两个浮点数是否相等不要直接用`==`,要通过相减并与预先设定的精度比较,要取绝对值
17. 指针参数传递和引用参数传递的区别?
    * 指针参数传递本质是值传递,会产生指针变量临时副本;如果要改变指针所指向的值,必须在函数内解引用,直接修改指针变量是不会修改到实参指针的
    * 引用参数传递时不需要解引用,并且函数对形参的任何操作都会直接影响主调函数的实参
    * 指针参数传递可以在函数内重新绑定,即修改实参的指向的地址;引用参数传递是不能重新绑定,因为引用初始化后就不能改变了
18. 类如何实现只能静态分配?
    将`new、delete`运算符重载为`private`属性
19. 类如何实现只能动态分配?
    把构造、析构函数设为`protected`属性,再用子类来动态创建
20. 继承机制中对象之间如何转换?指针和引用之间如何转换?
    向上类型转换:将派生类指针或引用转换为基类的指针或引用,这是自动进行的;
    向下类型转换:将基类指针或引用转换为派生类指针或引用被称为向下类型转换,这是不会自动进行的,可以利用`dynamic_cast`强制转换