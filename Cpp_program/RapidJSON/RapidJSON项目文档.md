1. 本项目是对腾讯的`RapidJSON`项目的一个学习,其最初灵感来源于`RapidXML`
2. 本项目的关键性能优化方法:
   * 使用模板及内联函数降低函数调用的开销
   * SIMD指令优化
   * 自定义内存分配器
   * 零拷贝技术
   * 跳过空白字符的优化算法:利用SIMD实现的
   * 字符串处理算法:优化算法处理转义字符
   * 使用经过优化的Grisu2算法(`dtoa.h`)和专门的浮点数解析算法->`double-conversion`中自定义的`DIY-FP`算法(`diyfp.h strtod.h`) (标准库的`strtod()`函数较缓慢(因为它是面向广泛情况,即包括了异常值、极端情况、错误处理等,所以较为缓慢),因此自己重新实现了) (大多数`JSON`文档中的浮点数往往是常见的简单小数,而不需要处理极端情况.相比之下,`strtod()`在处理任何浮点数时都必须走标准的复杂路径,导致性能开销较大)
# JSON
1. `JSON`是一种轻量级的数据交换格式,常用于客户端和服务器之间的数据传输:
   * 易于阅读和编写
   * 广泛支持:`JSON`与语言无关
   * 轻量级:`JSON`比`XML`更简洁,传输数据时占用的带宽更少
   * 易于解析
2. 为什么要使用`JSON`(`XML`)?
   * `JSON XML`都是纯文本格式,这意味着它们可以在不同的平台、编程语言和系统之间轻松传输和解析.这使得它们成为网络通信、`Web`服务、移动应用等领域的标准选择
   * `JSON XML`都是国际标准或广泛接受的标准格式,确保数据可以在多种应用程序、系统和服务之间无缝交换
   * `JSON XML`都十分易于阅读和理解,适合开发者直接查看和边集
   * 无论`JSON XML`,都有大量的库、工具和框架支持它们的解析和生成
# XML
1. `XML`:指的是可扩展性标记语言(`XML`格式与`HTML`类似)(`HTML`就是一种标记语言),`XML`的关注焦点是数据的内容(但它也可展示在浏览器中,但通常没有颜色、可视化处理等等,它只关注传输的内容);而`HTML`的关注焦点是数据的展示(通过浏览器打开`HTML`就能看出)  `HTML`旨在显示信息,而`XML`旨在传输信息
2. `XML`标签只能自定义(`HTML`标签不能自定义):
   ```xml
   <root>
   <user>
   LJJ
   </user>
   <msg>
   111
   </msg>
   </root>
   ```
3. `XML`数据格式最主要的功能就是数据传输,还常用于配置文件、存储数据(充当小型数据库).`XML`规范了数据格式,使数据具有结构性,易读易处理
4. `XML`与`JSON`:
   * `XML`由于大量的标签和属性,其文档往往很冗长;`JSON`更简洁,可读性更好
   * `XML`是基于标签的格式,`JSON`是基于键值对的格式
   * `XML`适合文档型数据,广泛用于配置文件、文档交换等,它可以有注释等;`JSON`更适合数据传输,尤其是在`Web`应用中作为服务器和客户端之间的数据交换格式
# DOM
1. 文档对象模型(`DOM`)是一个网络文档(`HTML XML`)的编程接口(本项目也支持`DOM SAX`的`API`,这只是一种类似说法,本项目的`DOM API`通过自定义的一个`Document`对象,提供了与`XML`的`DOM`类似的功能,使得可以方便地解析、访问、修改和重新生成`JSON`文档).如:`HTML DOM`定义了访问和操作`HTML`文档的标准方法(`XML`类似).`DOM`以树结构表达文档,树的每个结点表示了文档的标签或标签内的文本项,`DOM`树结构精确地描述了文档中标签间的相互关联性. <mark>文档->`DOM`的过程称为解析</mark>,`DOM`模型不仅描述了文档的结构,还定义了结点对象的行为,利用对象的方法和属性,可以方便地访问、修改、添加和删除`DOM`树的结点和对应内容(说白了,`DOM`就是为了更好的描述文档,并且可以更方便、统一方法来进行操作文档内容)
2. `DOM`的特点:
   * 树状结构:`DOM`将文档表示为一棵树,其中每个节点代表文档的一部分.如,在`HTML`中,节点可以是元素、属性、文本内容等.对于`JSON`,节点可以是对象、数组、字符串、数字、布尔值和`null`等
   * 随机访问:通过`DOM`模型,程序可以随机访问文档中的任何部分.你可以通过路径或键名直接访问特点节点,而不需要从头到尾顺序读取整个文档
   * 可修改性:`DOM`允许不仅读取文档,还可以修改其结构和内容,可以添加、删除、或更改节点,然后将修改后的文档重新序列化为字符串
   * `DOM`是将整个文档加载到内存中(将整个`JSON`文档解析到内存中),因此对于大型文档可能会占用较多的内存
# SAX
1. `SAX`是一种基于事件的解析技术,最早用于解析`XML`文档.它是一种流式解析方法,与`DOM`不同,`SAX`不会将整个文档加载到内存中,而是逐行读取文档,并在遇到特定标记时触发事件
2. `SAX`解析器逐行扫描`XML`文档,每当遇到特定的结构(如开始标签、结束标签、字符数据等)时,就会触发相应的事件(如`startElement`、`endElement`、`characters`等).开发者需要实现这些事件的处理器(`Handler`),以便在事件发生时执行特定的逻辑
3. 由于`SAX`解析器不需要将整个文档加载到内存中,因此它的内存占用非常小,特别适合处理大型文档或内存有限的场景
4. `SAX`是顺序处理的,它无法回溯或随机访问文档的某个部分
# Allocator
1. `CrtAllocator`为什么要用`C`来定义内存块分配函数:
   * 兼容性:C语言的标准库函数`malloc`、`realloc`和`free`是跨平台、广泛使用的内存管理工具.通过使用这些函数,CrtAllocator可以在几乎所有支持`C`的环境中运行,不依赖于`C++`特定的内存管理机制.这确保了`RapidJSON`在不同平台上的兼容性
   * 性能与开销:`C`语言的内存管理函数执行开销较小,并且可以直接分配或释放任意大小的内存块.与`C++`的`new`和`delete`相比,`malloc/free`的内存分配机制通常更加直接且底层,适合处理大量、快速的内存分配需求,如`RapidJSON`中频繁的内存操作
2. 内存池分配器`MemoryPoolAllocator`是如何实现高效的内存块分配的:
   * 预先分配大块内存=>减少系统(`malloc free`)调用
   * 内存池中每个内存块的链表管理
   * 按需分配新内存块=>当内存池中的当前内存块不足以满足某个内存请求时,分配器会按需分配一个新的内存块,而不是立即分配大量的内存.这种策略保证了内存的使用效率,并避免了内存浪费
   * 内存对齐操作
   * 避免内存碎片
   * `Free`操作的简化
   * `Clear`操作
3. 内存池分配器`MemoryPoolAllocator`通过统一管理内存块,减少了内存碎片的产生.内存池一次性分配较大的内存块,内部的小对象分配都来自同一块连续的内存区域
4. 内存池分配器`MemoryPoolAllocator`的`Free`实际是一个空操作,即内存块的回收并不是立即执行的.相反,内存块在整个内存池分配器被销毁时才会统一释放,这样避免了频繁的内存释放操作,进一步提升性能
5. 在某些情况下,用户可能需要手动释放内存池中的内存块.而`Clear()`函数会释放内存池中除了第一个块之外的所有内存块,确保内存池在这之后仍然可以被使用
6. 对齐内存边界重要性:对齐操作在计算机系统中非常重要,特别是在处理器访问内存时.处理器从内存读取数据时,通常是按块进行的,最常见的是按4字节(32位)或8字节(64位)读取.对齐的内存访问可以使得处理器只需要一次内存访问即可读取完整的数据,而不对齐的访问可能会导致处理器需要进行两次内存读取.如果数据没有对齐到合适的边界,处理器需要进行两次或更多次内存读取,将结果合并后才能得到所需的数据,这会增加延迟并降低性能
7. 本项目的对齐内存操作:
   ```C++
   1. 计算掩码
   const uintptr_t mask = sizeof(void*) - 1;// 若sizeof(void*)为8,则mask为7(0b111)
   2. 判断是否需要对齐
   if (ubuf & mask)// 若结果为0,则表示地址已经与32(64)位系统边界对齐了;否则,就需要对齐
   3. 计算对齐后的地址
   const uintptr_t abuf = (ubuf + mask) & ~mask;// 将地址向上(地址增大)对齐到最近的指针大小的倍数
   4. 调整内存块的剩余内存大小
   size -= abuf-ubuf;// 因为我们是向上对齐地址,因此对其操作会减少原始的剩余内存大小  则更新剩余的可用内存大小=原始剩余的可用大小-因为对齐而损失的内存大小
   ```
8. `MemoryPoolAllocator`预先分配大块内存:内存池分配器的核心思想是预先分配较大的内存块,然后在这些内存块中按需分配小对象.通过这种方式,内存池避免了频繁的动态内存分配调用,如`malloc`或`new`,从而显著提升了内存分配的效率.(当程序开始使用分配器时,内存池分配器会申请一个大块内存(如64KB).每次请求内存时,如果内存块内存大小足够,则内存池分配器会直接从预分配的内存块中分配;否则,会在`MemoryPoolAllocator`中重新分配一个内存块)
   ![](markdown图像集/2024-10-07-09-25-27.png)
9.  内存块(`ChunkHeader`表示的就是一块内存块)的链表结构:<mark>本项目的内存池分配器使用链表来管理每个内存块,`ChunkHeader *chunkHead`指向链表头部,链表中的每个节点(`ChunkHeader`)表示一个内存块.通过这个指针,分配器可以轻松地遍历所有的内存块,以便分配和释放内存.其中每个内存块都有一个头部`ChunkHeader`结构体来记录其容量和已分配的内存大小以及指向下一个内存块的指针(这个指针就实现了链表管理)</mark>
10. `ownBuffer`:
    * `ownBuffer=true`:表示内存池分配器自己管理该内存块.也就是说,内存块的分配和释放都由 `MemoryPoolAllocator`自己负责.此时,当分配器销毁时,它会负责释放这些内存块
    * `ownBuffer=false`:表示内存块是由用户提供的，并且`MemoryPoolAllocator`不会负责释放这些内存.这种情况适用于用户已经有一块现成的内存(如堆或栈上的内存),并希望将其提供给分配器使用.在这种情况下,当分配器销毁时,它不会试图释放由用户提供的内存块  此时当`MemoryPoolAllocator`析构时,它不会释放由用户提供的缓冲区,因为它不拥有这些内存
11. `SharedData`:
    ```C++
     struct SharedData {
        ChunkHeader *chunkHead;
        BaseAllocator* ownBaseAllocator; 
        size_t refcount;
        bool ownBuffer;
     };
     // size_t refcount:这个计数器用于跟踪有多少个MemoryPoolAllocator实例共享同一个SharedData对象.当一个分配器被复制(如,通过拷贝构造函数或赋值操作符)时,引用计数会增加;当一个分配器被销毁时,引用计数会减少.只有当引用计数减少到零时，才会真正释放SharedData所管理的内存,即内存池
     // bool ownBuffer:该字段指示内存块是否由 MemoryPoolAllocator自己管理.通过这个字段,分配器可以判断是否需要在析构时释放内存,避免错误地释放由用户提供的内存
     ```
12. 本项目中,每个内存池`MemoryPoolAllocator`实例通常会拥有自己独立的`SharedData`结构体,即<mark>一个内存池与一个`SharedData`一一对应</mark>
13. 本项目中<mark>一个内存块和一个`ChunkHeader`结构体是一一对应的</mark>
14. 一个内存池可以管理多个内存块,即一个`SharedData`结构体管理多个`ChunkHeader`结构体
15. <mark>内存池通过`SharedData`结构体,内存块通过`ChunkHeader`结构体设计来管理其元数据,而具体的`data`紧跟在头部之后,形成一个连续的线性空间.这种结构可以高效地进行内存分配和管理,同时支持多个内存块的链式组织,形成完整的内存池</mark>
16. `void *`是一种通用指针类型,可以指向任何类型的数据.在`C/C++`中,`void *`被广泛用于函数参数和返回值,这样可以允许代码处理各种数据类型而不需要显式指定类型.如:在内存块分配器`CrtAllocator`中,`void*`可以用于分配和返回任意类型的内存块，使得分配器更灵活
17. `static inline ChunkHeader *GetChunkHead(SharedData *shared)`:从内存池结构体`SharedData`中获取第一个内存块头`chunkHead`的起始地址,假设当前内存池`SharedData`的对齐大小为32字节,那么`shared`的地址从0开始,+32字节的偏移后得到 `ChunkHeader`的起始地址
18. `static inline uint8_t *GetChunkBuffer(SharedData *shared)`:返回当前内存块中`data`区域的起始地址,即跳过当前内存块的`chunkHead`.假设`ChunkHeader`的对齐大小为16字节,而`shared->chunkHead`的地址为0x1020,那么加上16字节后,数据区起始地址就是0x1030
    ![](markdown图像集/2024-10-06-23-12-39.png)
19. 只有最后一个分配的内存块(或者说是内存块的最后一个分配的内存对象)才能安全地扩展(这是因为它紧邻着当前内存块的未分配空间),这里的最后一个指的是当前内存块链表中最新分配的那块内存,它在当前内存块的已分配部分的末尾.假设某个内存块不是最后一个分配的块,而是中间的某个块,试图扩展它会破坏后续分配的内存块结构,导致内存重叠或越界
20. `if (originalPtr == GetChunkBuffer(shared_) + shared_->chunkHead->size - originalSize)`:如果相等,则表示需要重新分配的内存块的起始地址就是当前内存池分配的最新的(最后一个)内存块起始地址`originalPtr`是传入的需要重新分配或扩展的内存块的起始地址  `GetChunkBuffer(shared_)`返回当前内存块(`shared_->chunkHead`)的起始地址,这是当前内存池中最新分配的内存块的起始地址  `shared_->chunkHead->size`是当前内存块已经分配出去的内存大小  `originalSize`是要重新分配的内存块的原始大小.如:
    ![](markdown图像集/2024-10-07-09-21-48.png)
    ![](markdown图像集/2024-10-07-09-22-07.png)
    ![](markdown图像集/2024-10-07-09-22-17.png)
21. <mark>内存池中的内存块的分配是线性的</mark>
22. 不能说成在一个大内存块继续分配小内存块,因为内存块之间是独立的,都有一个自己的头部结构体`ChunkHeader`;只能说在一个大内存块上分配小的内存对象
