1. 指针和引用的区别

2. 介绍`std::unique_ptr`和`std::shared_ptr`

3. `std::shared_ptr`怎么保证线程安全的

4. `TCP/IP`有哪些层,每层有哪些协议

5. `LSM`树的写入和读取过程

6. 快排平均时间复杂度

7. 有序的数组的快排时间复杂度

8. 介绍`vector`和`list`,并分别应用在什么场景

9. `C++`实现线程安全的单例模式

10. `C++`实现多线程累加数,并说会有什么问题,怎么解决

11. `int* const`和`const int*`
    * `int* const`指的是顶层`const`:指的是`const`修饰的指针变量本身是一个常量,无法修改,
    * `const int*`指的是底层`const`:指的是`const`修饰的变量所指向的对象是一个常量,指的是所指变量,就是`*`号的左边

12. 下面代码有什么问题:
    ```C++
    void test() {
        int* a = new int[10];
        std::unique_ptr<int[]> ptr(a)
        std::vector<std::unique_ptr<int[]>> vec;
        vec.push_back(ptr);// 会调用ptr所属的类类型(std::unique_ptr)的拷贝构造函数
    }
    ```
    ![](2025-04-14-21-51-24.png)
    * `std::unique_ptr`是不允许左值复制和赋值操作(`std::unique_ptr`是禁止拷贝和赋值的),因此要用的话就要用`std::move`.`std::vector`的`push_back`对于`ptr`会利用拷贝构造函数构造一个临时对象再将这个临时对象拷贝或移动(用`std::move`)到容器中,因此不用`std::move`的话在`vector`的`push_back`就使用`std::unique_ptr`禁止的拷贝构造函数
    * 注意:换成`emplace_back`也是不行的,对于元素为`std::unique_ptr`对象的构造是不能通过传入一个左值对象`ptr`进行对象构造的(如果允许,那么就会调用拷贝构造函数),只允许移动构造
13. 下面代码有什么问题:
    ```C++
    void test() {
        std::unique_ptr<int> ptr1(new int(10));
        std::unique_ptr<int> ptr2 = ptr1;// 错误：无法复制 std::unique_ptr
    }
    ```
    `unique_ptr`不允许左值赋值
14. `TCP`三次握手时,客户端发送的`SYN`,服务器没有应答,此时客户端会怎样?