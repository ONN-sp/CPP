1. `WebServer`项目的难点,以及怎么解决的
   * 如何实现高并发?
    - 解决办法:`Reactor`模式是实现高并发的关键,采用`One Thread Per Loop`的线程模型,每个线程运行一个独立的事件循环;主`Reactor`(单线程):负责监听和接受新连接,通过`Acceptor`类将新连接分发给子`Reactor`;子`Reactor`(多线程);每个子`Reactor`运行在独立线程中,管理已建立连接的`I/O`事件.通常子`Reactor`数量与`CPU`核心数匹配,充分利用多核资源
   * 如何实现异步解耦的日志系统?
    - 解决办法:实现一个多生产者单消费者模型,即业务生产线程写入前端的当前缓冲区时不需要等待IO操作,当缓冲区写满后,立即切换到预备的缓冲区继续写入;消费后台线程则负责批量将这些缓冲区写入磁盘
   * `TCP`连接的生命周期管理
    - 解决办法:智能指针(基于`RAII`机制)
   * 性能不好,如主`CPU`拉满;压测效果不好时怎么解决的?
    - 解决办法:因为项目整体是按照模块进行设计的,所以从顶层向下依次调试,跟踪代码的运行状态,最终定位问题的位置;主`CPU`拉满是由于`listen()`中设置的同时监听数=5;压测效果不好是因为使用的是`Debug`调试模式
2. `LevelDB`项目的难点,以及怎么解决的
    * `LSM`顺序写的实现?
        - 解决办法:在内存中:首先将数据写入内存中的Memtable。Memtable是一个有序的数据结构（跳表），它按照键的顺序存储数据;在磁盘中:当Memtable达到一定大小时，它会被刷写到磁盘，形成一个SSTable文件。SSTable文件是按键顺序排列的
    * 数据一致性的保证,即数据恢复的实现?
        - 解决办法:实现预写机制`WAL`,即先把数据写到日志中,然后内存数据就是通过依次应用日志中的写操作来重构出来的
    * `LevelDB`数据库的`MVCC`是怎么实现的?
        - 解决办法:在每个写入操作都会被赋予一个唯一的序列号(`sequence number`),当进行读取操作时，LevelDB会根据读取操作开始时的序列号来确定它能够看到的数据版本(其实就是通过比较`sequence number`实现的)
    * 为了保证磁盘的数据是最新的,需要日志合并,那么怎么实现呢?
        - 解决办法:
            * `Minor Compaction`:将内存中的`MemTable`持久化为`SSTable`文件到`Level 0`(参数`write_buffer_size`控制`MemTable`大小,`max_write_buffer_number`控制内存中最多保留的`Immutable MemTable`数量),`Level 0`的`SSTable`文件允许键范围重叠(但是单个文件的键是有序的),因此查询`Level 0`需检查所有文件,这是`LevelDB`写入快但读取相对慢的原因之一
            * `Major Compaction'`:(跨层合并)这是对磁盘上的`SSTable`文件进行合并的过程,主要目的是减少文件数量、清理冗余数据,并提升查询效率.可以分为`size Compaction`、`seek Compaction`和`manual Compaction`:
              - `size Compaction`:当某一层(如`Level L`)的数据总量超过预设阈值时,触发跨层合并,如:
                 * `Level 0`的文件数量超过配置阈值(默认4个),此时的`compaction_score_`会大于等于1,则触发一次`Compaction`,并与`Level 1`中键范围重叠的`SST`文件合并,生成新的`SST`文件并写入`Level 1`,同时删除旧文件
                 * `Level L(L≥1)`的数据大小超过其目标容量(如`Level 1`为10MB,`Level 2`为100MB等) 
              - `seek Compaction`:当某个`SSTable`文件因频繁查询未命中(可能包含大量已删除或过期数据)时触发.每个`SSTable`有一个`allowed_seeks`计数器,初始值为文件大小`/16KB`,每次未命中查询会减少该值,归零时触发合并(`allowed_seeks`是每个文件允许的最大无效读取次数),将被标记的`SST`文件与下一层重叠的文件合并,清理上一层的无效数据
3. `RapidJSON`项目的难点,以及怎么解决
   * 自定义内存分配器的实现:通过阅读`ptmalloc`的源码,并仿造`ptmalloc`实现一个适用于`JSON`数据传输的更轻量级的内存分配器(自定义的内存分配器更简单,比如它不会对每个内存块进行释放,而是当`JSON`文档解析完成后统一对内存分配器进行销毁,即不会对单个对象进行`free`)
4. 项目遇到难点,怎么一步一步解决的:
   * 首先,独立解决
     - 通过查阅大量的相关技术文档、资料,包括官方文档、技术博客、论坛讨论等,深入思考问题
     - 验证不同的方法,并对每个方法的结果进行一个文档记录
     - 代码调试和优化:代码中的错误或性能瓶颈,首先我会使用调试工具对代码进行跟踪,找到问题并进行修复或优化
   * 借助他人
     - 向开源社区求助,并参考它们的解决办法
     - 询问做过类似项目的师兄、师姐
5. 科研中遇到难点是怎么解决的
   * 首先确定难点的本质,即棘手的点在哪
   * 然后深入查阅相关文献,关注最新研究进展,看看是否有人研究过类似的问题,并复现他们的思路
   * 在光纤通信中,可以通过仿真和实验的相互验证来寻找突破口
   * 可以和教研室的师兄师姐、老师讨论相关难点,可能提供不一样的思路
   * 也可以参加相关学术会议,从会议上得到研究灵感
6. 为什么选择加入我们?
   因为王者荣耀作为现象级MOBA手游，后台系统复杂，涉及高并发网络请求处理、海量游戏数据存储与管理等技术难题。参与其中，能锻炼解决实际复杂问题的能力，积累宝贵的大型项目开发经验，为我带来一次含金量十足的实习经历，为后面的职业发展有很大的好处
7. 你的优势在哪里?
   * 扎实的编程技能，良好的编程习惯
   * 定位问题、解决问题能力还行
   * 通过项目积累了较为丰富的后台开发经验
   * 快速学习新技术的能力
   * 良好的团队合作精神
   * 工作负责，自制力强