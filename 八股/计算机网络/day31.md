1. 一个服务器进程最大支持的`TCP`连接数是多少?
   `TCP`连接本质上在内核里就是一个`socket`对象,一个`socket`对象就是一个四元组的数据结构-源IP、源端口、目标IP、目标端口.一个服务端进程,它的IP、端口是固定的,因此只有客户端可以变了,所以一个服务端进程最大能支持的`TCP`连接个数=客户端`IP`数*客户端的端口数,对于`IPv4`,客户端的`IP`数最多有2^32,客户端的端口数最多为2^16,即一个服务端进程最大能支持的`TCP`连接个数=2^48.但是,服务端的进程最大能支持的`TCP`连接数不能达到理论上限,因为会受到文件描述符、内存大小资源的限制
2. 一台服务器最大最多能支持多少条`TCP`连接?
   一条静止的`TCP`连接(不发送数据、不接收数据)占用的大小(一个`TCP`对象占用的大小等于它所包含的一些数据结构占用大小的总和)是3.44KB=0.81KB+2.19KB+0.19KB+0.25KB,因此只考虑静态状态的`TCP`时,8GB物理内存的服务器最大能支持`TCP`连接数=8GB/3.44KB=2438956(约240万)
3. `bind、listen、accept、connect`等函数是用户态程序调用的库函数,但是他们都会触发系统调用,进入内核态。在用户代码里调用后，CPU 必须从用户态切换到内核态，由内核里的 TCP/IP 协议栈完成真正的操作，在大多数情况一次系统调用就会触发一次完整的用户态→内核态→用户态的往返
4. 服务端调用`listen`后`sleep`休眠,客户端的`connect`能成功吗?三次握手能成功吗?
   `sleep`只会让当前用户态进程进入休眠状态,不会影响内核的运行.在操作系统中,内核负责管理网络协议栈,包括`TCP`协议的实现,因此服务端`sleep`后不会影响后续的三次握手环节,此时会将三次握手完成的`TCP`连接放到全连接队列,等待后续服务端调用`accept`来获取连接
5. `accept`是在三次握手之后调用的,它接收的就是三次握手成功后放入`TCP`全连接队列中的`TCP`连接
6. `listen(fd, 128)`:让 fd 进入监听状态，并且最多允许 128 个尚未被 accept() 取走的连接在队列里排队，这是全连接队列，listen得到的是全连接队列
7. 半连接队列：客户端第一次SYN后服务器发送ACK后服务端的状态，此时三次握手未完成；全连接队列： 三次握手已完成、等待服务器 accept() 取走的连接队列