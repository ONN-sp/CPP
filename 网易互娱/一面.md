1. C++中，拷贝构造函数的函数签名中的参数是const左值引用，移动构造函数的是非const右值引用，因为拷贝构造不会改原对象，因此加了const；而移动构造需要将原对象资源移动走，需要修改原对象，因此是非const
2. C++中，对const修饰的变量使用std::move()时，会调用拷贝构造函数而不是移动构造函数：因为对const变量使用std::move会得到const T&&类型，而移动构造函数无法接受const右值引用。编译器会优先匹配移动构造函数，但const T&&无法转换为T&&，因此它会退而选择拷贝构造
3. 在多线程程序使用fork()会产生一系列问题，主要原因是fork()只复制调用线程，不复制其他线程。主要问题包括：
  * 死锁：fork()只复制当前线程，其他线程瞬间消失；如果消失的线程持有锁，这些锁在子进程中永远无法被释放，即造成死锁
  * 状态不一致：其他线程可能正在修改共享数据结构，fork()瞬间终止这些线程，导致数据结构处于不一致状态
4. C++中的可变参数：可以用C++11可变参数模板实现
    ```C++
    // 可变参数模板
    template<typename T, typename... Args>
    void print(T first, Args... args) {
        std::cout << first << " ";
        print(args...); // 递归调用
    }
    ```
    参数包展开的各种方式:
    ```C++
    template<typename... Args>
    class VariadicProcessor {
    public:
        // 1. 直接展开到容器
        static std::vector<int> toVector(Args... args) {
            return {args...}; // 展开到初始化列表
        }
        // 2. 展开到tuple
        static std::tuple<Args...> toTuple(Args... args) {
            return std::make_tuple(args...);
        }
        // 3. 条件展开（C++17）
        template<typename T>
        static void printIfIntegral(Args... args) {
            ((std::is_integral_v<Args> ? (std::cout << args << " ") : (void)0), ...);
            std::cout << std::endl;
        }
        // 4. 带索引的展开
        static void printWithIndex(Args... args) {
            size_t index = 0;
            (((std::cout << "[" << index++ << "] = " << args << "\n")), ...);
        }
    };
    ```
    访问特定位置的参数，可以使用std::tuple+std::get
5. tuple是C++11引入的一个重要标准库组件，它允许将多个不同类型的值组合成一个单一对象，如:`std::tuple<std::string, int, double> person("Bob", 30, 180.2);`
6. 绝大多数情况32位程序都可以在64位系统中运行，核心在于WoW64（WoW64 是 Windows on Windows 64-bit）子系统，它是64位操作系统中的一个关键兼容层，其唯一任务就是为32位应用程序创造一个独立的、仿真的32位运行时环境 
7. 除了经典的`one loop per thread`高并发设计，还有其它的吗？
   * 线程池：最常见的替代方案，预先创建一组线程处理任务，减少线程创建、销毁的开销和线程竞争
   * 领导者-追随者方案：线程轮流担任领导者角色处理事件。一个线程作为领导者等待事件；事件到达后，领导者变为处理者，选举新领导者；处理完成后线程回归追随者队列。这种方式避免线程间通信开销，响应更及时
   * 流水线：将处理过程分解为多个阶段，每个阶段由专门线程处理，如：
    ```txt
    接收 → 解析 → 处理 → 编码 → 发送
    ↓      ↓      ↓      ↓      ↓
    线程1   线程2   线程3   线程4   线程5 
    ```
   * Actor模型：每个actor是独立并发实体，通过消息传递通信 。actor是不需要加锁的，它们各自维护了一个队列，用于串行处理消息；actor通信是异步的，不会阻塞等待
8. 洗牌算法是一种用于将一组数据随机重新排列的算法，确保每种可能的排列出现的概率相等，比如经典的Fisher-Yates洗牌算法（从数组的最后一个元素开始，随机选择一个位置（包括当前位置）进行交换，然后向前移动）
9. 普通调用和系统调用的不同
    * 普通调用是用户程序内部函数，在用户空间调用；而系统调用是用户程序向操作系统请求服务，会从用户空间切换到内核空间，一般是通过内核接口进行调用的
10. 共享内存就是两个或多个进程的虚拟地址通过页表映射到同一片物理地址以便于通信，共享内存是进程间通信中传输速度最快的通信方式，因为客户进程和服务进程传递的数据直接从内存里存取、放入，数据不需要在两进程间复制
11. 共享内存实现方式：POSIX共享内存（shm_open一个内存共享对象+mmap）；System V共享内存（shmget+shmat）；通过文件映射实现共享内存（open一个磁盘文件+mmap映射到文件）
12. 共享内存就是两个或多个进程的虚拟地址通过页表映射到同一片物理地址以便于通信，如果某个进程向共享内存写入数据，所做的改动将影响同一段共享内存的任何其他进程。共享内存是进程间通信中传输速度最快的通信方式，因为客户进程和服务进程传递的数据直接从内存里存取、放入，数据不需要在两进程间复制