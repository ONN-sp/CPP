1. 类会什么情况下自动生成默认构造函数
   * 类没有定义任何构造函数时，且它还需要构造函数时(如:类含有虚函数或虚继承:如果类声明了虚函数或使用了虚继承,编译器生成的默认构造函数会赋值初始化虚表指针)
   * 定义了其它构造函数,再用`default`关键字就能保留默认构造函数
2. 抽象类
   * 定义:带有纯虚函数的类为抽象类
   * 作用:抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中,由它来为派生类提供一个公共的根,派生类将具体实现在其基类中作为接口的操作
   * 抽象类只能作为基类来使用:如果派生类中没有重新定义纯虚函数,而只是继承基类的纯虚函数,则这个派生类仍然还是一个抽象类
3. 模板类和模板函数的区别:函数模板的实例化是由编译程序在处理函数调用时自动推导模板参数类型的,因此实例化时可以省略尖括号`<>`;而类(结构体)模板的实例化必须由程序员在程序中显示地指定,即必须加`<T>`
4. 多继承的优缺点:
   * 多继承允许一个派生类指定多个基类,这样的继承结构被称作多继承
   * 多继承可以使对象调用多个基类中的接口
   * 如果派生类所继承的多个基类中有相同的成员,而派生类对象需要调用这个接口方法,就会出现二义性
   * 加上域解析符可以解决二义性
   * 使用虚继承可以解决菱形继承中的二义性
5. 多继承不推荐使用,`java、C#`中都没有多继承
6. `C++`中,类本身在声明和定义的时候并不会分配内存,只有在实例化对象时才会为该对象分配内存
7. `C++`中,模板本身在声明和定义和实例化时不会分配内存,模板只有在对实例化后的模板函数/结构体/类再进行实例化才分配内存.模板定义和声明通常都放在头文件中
8. 拷贝构造函数的参数必须是引用类型不能是值类型:如果拷贝构造函数的参数不是引用,而是值类型,那么当向拷贝构造函数传递参数时,编译器会尝试创建一个临时对象来作为参数,而创建这个临时对象的过程又会调用拷贝构造函数,这就导致了无限递归的情况,最终导致内存溢出
9. 静态成员函数为什么不能定义为虚函数:`static`成员没有`this`指针,而虚函数的访问需要通过虚表指针进行,而虚表指针需要通过`this`指针来访问,因此静态成员函数不能定义为虚函数
10. 虚函数的调用关系:`this->vptr->vtable->virtual function`
11. 虚函数的代价
    * 带有虚函数的类,每一个类会产生一个虚函数表,用来存储指向虚成员函数的指针,消耗空间
    * 带有虚函数的类的每一个对象,都会有一个指向虚表的指针,消耗空间
    * 不能再是内联函数,因为内联函数在编译阶段进行替代,而虚函数表示等待,在运行阶段才能确定采用哪种函数
12. 构造函数的执行顺序:
    * 在派生类构造函数中,所有的虚基类及上一层基类的构造函数调用
    * 对象的虚表指针被初始化
    * 如果有成员初始化列表,将在构造函数体内展开,这必须在虚表指针被设定后才做
    * 执行程序员提供的代码
13. 一个类中的全部构造函数的扩展过程是怎样的
    * 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内,并与成员的声明顺序为顺序
    * 如果一个成员并没有出现在成员初始化列表中,但它有一个默认构造函数,那么默认构造函数必须被调用
    * 所有上一层的基类构造函数必须被调用
    * 所有虚基类的构造函数必须被调用
14. 哪些函数不能是虚函数
    * 构造函数
    * 内联函数
    * 静态函数
    * 友元函数:友元函数不属于类的成员函数,不能被继承.对于没有继承特性的函数没有虚函数说法
    * 普通函数:普通函数不属于类的成员函数,不具有继承特性,因此普通函数没有虚函数