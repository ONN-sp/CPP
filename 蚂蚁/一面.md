1. 总结一些`leveldb`和`redis`的不同?
   * 存储方式:LevelDB是一个持久化的键值存储系统，主要将数据存储在磁盘上。它通过将数据分层存储在不同的层级文件中，利用日志结构合并树（LSM Tree）来优化写入性能;Redis是一个内存型的键值存储系统，数据主要存储在内存中。这种方式使得Redis在读写速度上非常快，每秒可以处理数十万次请求
   * 性能特点:
     - 写入性能:LevelDB适合写密集型的应用，因为它使用了LSM树结构，能够高效地处理写入操作。而Redis由于数据存储在内存中，写入速度也非常快，但在处理大量数据时可能会受到内存限制.在主从模式中,写操作主要集中在单个主节点上,这会导致主节点的写入压力较大,而且数据同步到从节点也需要一定的时间和资源,这也会限制写操作的性能
     - 读取性能:在单个键的读取时，Redis的性能通常更优，因为它是内存储存。而LevelDB在读取时需要从磁盘读取数据，不过它通过Compaction操作对数据进行整理和压缩，以减少数据规模和文件数量，从而加快读取速度
   * 数据结构:LevelDB只支持简单的键值对存储;Redis支持丰富的数据结构，如字符串、哈希、列表、集合和有序集合等
   * 持久化:LevelDB天然支持持久化，数据默认存储在磁盘上;Redis需要额外配置以确保数据持久化，它支持RDB（快照）和AOF（Append-Only File）两种持久化方式
   * 扩展性:LevelDB本身是一个单机的键值存储系统，如果需要实现分布式存储，需要借助额外的组件;Redis支持主从复制和分片集群来实现分布式部署,通过集群模式，Redis可以实现高可用性和水平扩展，以应对大规模数据和高并发访问的需求
2. `leveldb`在什么场景应用?`Redis`在什么场景应用?
   * LevelDB：适合嵌入式系统（如Android应用），以及需要处理大量临时数据的场景。它也适用于需要长期保存大量数据且对写入性能要求较高的应用
   * Redis：适合需要高速读写、实时数据分析、会话管理等场景。例如，作为缓存系统、消息队列、计数器等，在高并发和对读写速度要求极高的应用中表现出色
3. `deepseek`底层架构基于`Transformer`架构,包括:混合专家(`MoE`)架构、多头潜在注意力(`MLA`)架构、多`Token`预测训练目标(`MTP`)
4. `Transformer`架构?
   * Transformer由编码器（Encoder）和解码器（Decoder）两部分组成。编码器负责将输入序列转换为连续的表示，解码器则根据编码器的输出生成目标序列
   * 多头注意力机制是Transformer的核心创新。多头注意力机制允许模型在不同的表示子空间中并行地关注输入序列中不同位置之间的关系，从而更好地捕捉序列中的长期依赖和语义信息
   * 在编码器和解码器的每个块中，除了多头注意力机制外，还包含一个前馈神经网络(其中应用了Resnet网络中的残差连接)。这个网络对每个位置的表示进行变换，进一步增强模型的表达能力
5. `LevelDB`的日志恢复过程?
   `LevelDB`的恢复过程主要有`version`和内存数据的两种恢复,`version`的恢复过程为:
    * 利用Current文件读取最近使用的manifest文件；
    * 创建一个空的version，并利用manifest文件中的session record依次作apply操作，还原出一个最新的version，注意manifest的第一条session record是一个version的快照，后续的session record记录的都是增量的变化；
    * 将非current文件指向的其他过期的manifest文件删除；
    * 将新建的version作为当前数据库的version;
   Memtable 数据的丢失：Memtable 是内存中的数据结构，掉电或崩溃后，Memtable 中的数据会丢失.在写入数据时，LevelDB会先将数据写入日志文件（WAL），然后再写入 Memtable 。如果在写入 Memtable 后、数据持久化到 SSTable 之前发生掉电或崩溃，Memtable 中的数据会丢失，但日志文件中仍然保留了这些数据其内存数据的恢复过程:
    * 扫描日志文件：LevelDB会扫描所有未处理的日志文件，找到其中的写操作记录。
    * 重放日志记录：将日志文件中的写操作重新应用到一个新的 Memtable 中。如果日志文件中的数据量较大，可能会触发 Memtable 的`Compaction`操作，生成新的 SSTable 文件。
    * 更新版本信息：在恢复过程中，LevelDB会更新版本信息（Version），确保数据库的状态与日志文件中的记录一致
6. `LevelDB`的`Compaction`过程?
   * `Minor Compaction`:将内存中的`MemTable`持久化为`SSTable`文件到`Level 0`(参数`write_buffer_size`控制`MemTable`大小,`max_write_buffer_number`控制内存中最多保留的`Immutable MemTable`数量),`Level 0`的`SSTable`文件允许键范围重叠(但是单个文件的键是有序的),因此查询`Level 0`需检查所有文件,这是`LevelDB`写入快但读取相对慢的原因之一
    * `Major Compaction'`:(跨层合并)这是对磁盘上的`SSTable`文件进行合并的过程,主要目的是减少文件数量、清理冗余数据,并提升查询效率.可以分为`size Compaction`、`seek Compaction`和`manual Compaction`:
      - `size Compaction`:当某一层(如`Level L`)的数据总量超过预设阈值时,触发跨层合并,如:
         * `Level 0`的文件数量超过配置阈值(默认4个),此时的`compaction_score_`会大于等于1,则触发一次`Compaction`,并与`Level 1`中键范围重叠的`SST`文件合并,生成新的`SST`文件并写入`Level 1`,同时删除旧文件
         * `Level L(L≥1)`的数据大小超过其目标容量(如`Level 1`为10MB,`Level 2`为100MB等) 
      - `seek Compaction`:当某个`SSTable`文件因频繁查询未命中(可能包含大量已删除或过期数据)时触发.每个`SSTable`有一个`allowed_seeks`计数器,初始值为文件大小`/16KB`,每次未命中查询会减少该值,归零时触发合并(`allowed_seeks`是每个文件允许的最大无效读取次数),将被标记的`SST`文件与下一层重叠的文件合并,清理上一层的无效数据
      - `Manual Compaction`:手动紧凑化,`LevelDB`确实支持通过`CompactRange()`方法手动触发紧凑化,合并不同层级的`SSTable`以减少冗余数据,并提升查询效率


   