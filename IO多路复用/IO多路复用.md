1. I/O多路复用:单线程或单进程同时监测若干个文件描述符(监听文件描述符、通信文件描述符)是否可以执行IO操作的能力
2. 发展历程:一切的开始,都起源于这个`read`函数是操作系统提供的,而且是阻塞的,我们叫它阻塞IO.为了破这个局,程序员在用户态通过多线程来防止主线程卡死(阻塞).后来操作系统发现这个需求比较大,于是在操作系统层面提供了非阻塞的`read`函数,这样程序员就可以在一个线程内完成多个文件描述符的读取,这就是非阻塞IO.但多个文件描述符的读取就需要遍历,当高并发场景越来越多时,用户态遍历的文件描述符也越来越多,相当于在`while`循环里进行了越来越多的系统调用.后来操作系统又发现这个场景需求量较大,于是又在操作系统层面提供了这样的遍历文件描述符的机制,这就是IO多路复用.多路复用有三个函数,最开始是`select`,然后又发明了`poll`解决了`select`文件描述符的限制，然后又发明了`epoll`解决`select`的三个不足
3. I/O多路复用通常与非阻塞I/O一起使用,这意味着当没有数据可用时系统调用不会阻塞进程(线程),而是立即返回一个错误或特定的状态.这种方式可用避免浪费CPU时间在等待I/O操作完成上,使得程序能够更加响应快速地处理其它任务
4. 举个例子,一个常见的使用多路复用的情况是网络编程中的服务器.服务器可能需要同时处理多个客户端的连接请求.通过使用多路复用，服务器可以同时监听多个客户端连接,而不必为每个连接创建一个线程或进程.这样可以更高效地利用系统资源,并且可以更容易地管理并发连接
5. `epoll`比`poll`和`select`效率更高:
   ```C++
   1. epoll:linux,底层是红黑树(无检测上限)
   2. select:可以跨平台,底层是线性表(默认的检测上限1024)
   3. poll:linux,底层是线性表
   ```
6. IO多路复用就是通过内核同时监听若干个文件描述符, 然后将可以进行IO操作的文件描述符告诉我们,即读缓冲区或写缓冲区可以进行操作,那么可以调用相应的`read`或`write`方法.此时调用`read  write`是不会阻塞的,因为此时内核已经把文件描述符是否可以进行IO操作的检测做完了.但是需要注意:假设内核检测后告诉我们有10个文件描述符是可以进行IO操作的,此时虽然检测是同时的,但是在实际处理各个新连接或通信数据的时候是顺序进行的.(I/O多路复用确实允许程序同时监视多个文件描述符,并且在任何一个文件描述符上发生事件时能够立即响应.这种并行性是指程序可以同时监视多个文件描述符的状态,而不必等待一个文件描述符的 I/O 操作(`read write accept等`)完成后再监视另一个文件描述符.然而,对于每个文件描述符的处理,在事件发生时,通常是按顺序进行的.<mark>这意味着在事件循环中,程序会逐个检查每个文件描述符的状态,如果有事件发生,则按顺序处理.即文件描述符的处理是按顺序处理的,只是并行检测而已</mark>.因此,虽然程序可以并行地监视多个文件描述符的状态,但实际的处理过程可能是顺序执行的)
7. `accept`和`read`在服务器端对应的是套接字的读缓冲区,`write`对应的是写缓冲区
8. 多路复用适合处理连接数较多但每个连接的工作量不大(每个客户端和服务器交互过程很小,主要是在建立连接上)的场景,如高并发的网络服务器(即大部分实际时间都在IO操作上)
9. <mark>每个文件描述符对应的都是一个读缓冲区和写缓冲区</mark>
10. `select`:
   ```C++
   struct timeval{
      time_t tv_sec;//秒
      suseconds_t tv_usec;//毫秒
   };
   int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);
   //nfds:委托内核检测的这三个集合中最大的文件描述符(值)+1
   //readfds:文件描述符集合,内核只检测这个集合中文件描述符对应的读缓冲区.检测这些文件描述符对应的读缓冲区是不是可读
   //writefds:文件描述符集合,内核只检测这个集合中文件描述符对应的写缓冲区.检测这些文件描述符对应的写缓冲区是不是可写
   //exceptfds:检测这些文件描述符对应的缓冲区是不是异常
   //timeout:select函数的检测时长.如果指定为NULL,并不是说不阻塞,而是说当select检测的集合里若没有文件描述符就绪,那么就让select函数一直检测;当出现了就绪的文件描述符,select就可以返回了

   //返回值为就绪的文件描述符个数.readfds writefds exceptfds返回后是会被修改的
   ``` 
11. `fd_set`:
    ![](fd_set.png)内核在顺序遍历这个读集合的过程中,如果被检测的文件描述符对应的读缓冲区中没有数据,内核将修改这个文件描述符在读集合`fd_set`中对应的标志位,改为0,如果有数据那么标志位的值不变,还是1

    ![](fd_set2.png)当`select()`函数解除阻塞后,被内核修改过的读集合通过参数传出,此时集合中只要标志位的值还为1,那么它对应的文件描述符肯定是就绪的,我们就可以基于这个文件描述符和客户端建立新连接或通信了
12. 相关操作函数:
    ```C++
    1. FD_ZERO(fd_set *set);//清空文件描述符集合.它将给定的fd_set数据结构中的所有位置都设置为0
    2. FD_SET(int fd, fd_set *set);//将指定的文件描述符fd添加到文件描述符集合中.这意味着将fd对应的位设置位1,表示该文件描述符处于就绪状态.在调用select之前,应该使用此函数将要监视的文件描述他添加到fd_set中
    3. FD_ISSET();//检查指定的文件描述符fd是否在文件描述符集合中被设置.如果fd对应的位=1,则表示该文件描述符处于就绪状态,该函数返回非零值;否则返回0.通常在调用select后使用此函数检查哪些文件描述符已准备好进行I/O操作
    4. FD_CLR();//将指定的文件描述符fd从文件描述符集合中清除.这意味着将fd对应的位设置为0,表示不再监视该文件描述符
    ```
13. IO多路复用的优点:
    * 资源节约:IO多路复用可以通过一个线程同时监视多个IO事件,而不是为每个IO事件创建一个线程或进程
    * 高并发性:通过IO多路复用,一个线程可以同时处理多个IO时间,因此能够更高效地处理大量并发连接
    * 低延迟
    * 简化代码逻辑
17. IO事件:指的是输入/输出操作发生或完成时发生的事件.在计算机系统中,IO事件通常与IO操作相关联,例如从文件读取数据、向网络发送数据等,具体IOP事件包括:
    * 可读事件:当一个IO通道(套接字、管道、文件等)中有数据可读时(如套接字的读缓冲区有数据时),会触发可读事件
    * 可写事件:当一个IO通道有足够的空间可以接收新的数据时,会触发可写事件
    * 异常事件:当IO通道发生异常(如套接字连接中断、套接字错误等)时,会触发异常事件
