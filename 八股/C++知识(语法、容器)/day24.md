1. `int main(int argc, char* argv[])`:程序入口点,其中:</mark>
   * `argc`:一个整数,表示传递给程序的命令行参数的数量,它至少为1,因为命令行第一个参数永远是程序的名称(通常是可执行文件的路径)   `argc`不用手动传入,命令行手动传入的是`argv[1]`及后面的参数,`argc`会自动被设置
   * `argv`:一个字符指针数组,表示传递给程序的实际命令行参数.`argv[0]`是指向程序名称的字符串,`argv[1]`到`argv[argc-1]`包含了传递给程序的其它参数
2. 一个空类,默认会添加哪些函数?
   * 缺省构造函数(默认构造函数)
   * 拷贝构造函数
   * 析构函数
   * 赋值运算符
3. `C++`中标准库
   * 标准函数库:这个库是由通用的、独立的、不属于任何类的函数组成的,继承自C语言;面向对象类库:这个库是类及其相关函数的集合
   * 输入/输出IO、字符串和字符处理、数学、时间、日期和本地化、动态分配、其它、宽字符函数
   * 标准的C++ IO类、String类、数值类、STL容器类、STL算法、STL函数对象、STL迭代器、本地化库、异常处理类、杂项支持库
4. `string`、`const char*`和`char*`的转换关系
   * `string`->`const char*`:`.c_str()`
   * `const char*`->`string`:直接传入即可,`string s(c_s)`
   * `string`->`char*`:
    ```C++
    string s = "abc";
    char* c;
    const int len = s.length();
    c = new char[len+1];
    strcpy(c,s.c_str());
    ```
   * `char*`->`string`:直接传入即可,`string s(c)`
   * `const char*`->`char*`:`const_cast`也可以
    ```C++
    const char cpc = "abc";
    char* pc = new char[strlen(cpc)+1];
    strcpy(pc,cpc);
    ```  
   * `char*`->`const char*`:直接赋值即可,`const char* cpc = pc`
5. 静态绑定:绑定的是对象的静态类型,某特性(如函数依赖于对象的静态类型,发生在编译器);动态绑定:绑定的是对象的动态类型,某特性(如函数依赖于对象的动态类型,发生在运行期)
6. 如何设计一个计算仅单个子类的对象个数?
   * 为类设计一个`static`静态成员变量`count`作为计数器
   * 类定义结束后初始化`count`
   * 在构造函数中对`count`+1
   * 设计拷贝构造函数和赋值运算符,进行时`count`+1
   * 在析构函数中`count`-1
7. 成员初始化列表会在什么时候用到?
   * 初始化一个引用成员变量时
   * 初始化一个`const`成员变量时
   * 当调用一个基类的构造函数时,而它拥有一组参数
   * 当调用一个成员类的构造函数时,而它拥有一组参数
8. 成员初始化列表的调用过程怎样的?
   编译器会一一操作初始化列表,以适当顺序在构造函数之内安插初始化操作,并且在任何显示用户代码前.初始化列表中的顺序是由类中的成员声明顺序决定的,不是初始化列表中写的排列顺序决定的
9. 什么时候用引用作为函数参数,什么时候用指针作为函数参数?
   * 使用指针：
    - 参数可能为空
    - 需要重新绑定或操作指针本身
   * 其余情况都是优先考虑引用作为函数参数
10. 将引用作为返回值的好处?引用作为返回值的限制环境
    * 用引用作为返回值最大的好处就是在内存中不产生被返回值的副本
   ```C++
    class Data {
      private:
         int value;
      public:
         Data(int val) : value(val) {
            std::cout << "Data object created with value: " << value << std::endl;
         }
         // 返回值的引用
         int& getValue() {
            return value;
         }
         // 返回值的副本
         int getValueCopy() {
            return value;
         }
      };
      // int& getValue()返回成员变量value的引用,而不是副本(此时可以通过引用直接修改原始成员变量的值);int getValueCopy()返回的是成员变量value的副本
   ```
   * 不能返回局部变量的引用,因为函数返回以后局部变量就会被销毁,此时可能导致悬空引用
   * 通常只返回类成员变量或静态变量的引用
11. `strcpy`、`sprintf`、`memcpy`的不同
    * 操作对象不同
      - `strcpy`的两个操作对象均为字符串
      - `sprintf`的操作源对象可以是多种数据类型,只是目的操作对象是字符串,即转换为字符串
      - `memcpy`的两个对象就是两个任意可操作的内存地址,并不限于何种数据类型
    * 执行效率不同
      - `memcpy`>`strcpy`>`sprintf`
    * 实现功能不同
      - `strcpy`主要实现字符串变量间的拷贝
      - `sprintf`主要实现其它数据类型格式到字符串的转化
      - `memcpy`主要是内存块间的拷贝
12. 将引用作为函数参数的好处
    * 传递引用给函数与传递指针的效果是一样的
    * 使用引用传递函数的参数,在内存中并没有产生实参的副本,它是直接对实参操作
    * 使用指针作为函数的参数虽然也能达到与使用引用的效果,但是,在被调函数中同样要给形参分配存储单元(形参指针),且需要重复使用解引用的方式进行运算,造成性能消耗;而引用作为参数完全不会      
13. 数组和指针的区别
    * 数组在内存中是连续存放的,开辟一块连续的内存空间;数组所占存储空间:`sizeof(数组名)`;数组大小:`sizeof(数组名)/sizeof(数组元素数据类型)`
    * `sizeof(数组名)`得到的是数组的所有元素的总大小;`sizeof(指针)`得到的是一个指针变量的字节数(在`sizeof`运算符中,数组名不会退化为指针)
    * 编译器为了简化对数组的支持,实际上是利用指针实现了对数组的支持.具体来说,就是将表达式中的数组元素引用转换为指针加偏移量的引用
    * 在使用下标的时候,两者的用法相同,都是原地址加上下标值,不过数组的原地址就是数组首元素的地址是固定的,指针的原地址就不是固定的
14. 如何阻止一个类被实例化?
    * 将类定义为抽象基类(纯虚)或者将构造函数声明为`private`
    * 不允许类外部创建类对象,只能在类内部创建对象
15. `Debug`和`Release`的区别
    * `Debug`表示调试版本,包含调试信息,所以容量比`Release`大很多,并且不进行任何优化,便于程序员调试.`Debug`模式下生成两个文件,处理`.exe`或`.dll`文件外,还要一个`.pdb`文件,该文件记录了代码中断点等调试信息
    * `Release`表示发布版本,不对源代码进行调试,编译时对应用程序的速度进行优化,使得程序在代码大小和运行速度上都是最优的.`Release`模式下生成一个文件`.exe`或`.dll`
16. `main`函数的返回值有什么值得考究之处吗?
    `main()`函数返回值必须是`int`,这样返回值才能传递给操作系统表示程序正常退出
17. 写一个比较大小的模板函数:
    ```C++
    template<typename T>
    T Compare(T& a, T& b) {
      return a>b ? a:b;
    }
    ```
18. `strcpy`和`strncpy`的区别?哪个函数更安全?
    * `strcpy`将源字符串(包括终止字符`'\0'`)复制到目标缓冲区;`strncpy`将源字符串的前n个字符复制到目标缓冲区
    * `strcpy`不安全,如果源字符串超过的目标内存空间的大小会导致缓冲区溢出;`strncpy`相对更安全,因为它限制了复制的字符数量(如果复制的字符个数n>源字符串长度,`strncpy`会用空字符填充目标缓冲区;如果源字符串长度>=n,则不会在目标缓冲区添加结束符`'\0'`,可能导致未终止的字符串)
         