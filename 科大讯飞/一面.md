1. 模板经过编译后变成怎样？
   变成了用具体类型替换模板参数后的函数、结构体、类实例，其实就是模板实例化后得到的
2. 内存对齐的原因：对齐操作在计算机系统中非常重要,特别是在处理器访问内存时.处理器从内存读取数据时,通常是按块进行的,最常见的是按4字节(32位)或8字节(64位)读取.对齐的内存访问可以使得处理器只需要一次内存访问即可读取完整的数据,而不对齐的访问可能会导致处理器需要进行两次内存读取.如果数据没有对齐到合适的边界,处理器需要进行两次或更多次内存读取,将结果合并后才能得到所需的数据,这会增加延迟并降低性能
3. 右值引用(右值引用不能绑定到左值)：右值引用是一种专门用于绑定到右值的引用类型,语法是`T&&`.可以延迟临时对象的生命周期,`string &&c=string("hello");;// 此时就把string("hello")临时对象延长了，如果不用右值引用那么临时对象在这一句后就立即销毁`。其核心应用：
   * 实现移动语义:允许我们将资源从一个对象移动到另一个对象，而不是拷贝，更高效。既此时对于类来说，其构造函数和赋值运算符的参数就可以是右值引用，在传入右值时调用的就是移动构造函数或移动赋值函数，而不是拷贝构造和拷贝赋值
   * 实现完美转发：在函数模板中当使用右值引用作为模板参数时,可以根据实参的类型来推导出参数类型是左值引用还是右值引用,然后保持其原有类型(是左值就转发为左值引用被模板收到，是右值就转发为右值引用被模板收到)转发，此时一般是要和`std::forward`一起使用
4. 怎么实现内存起始对齐：不满足对齐时，编译器会插入填充字节，把结构体或变量的起始地址垫到满足对齐要求的位置（比如向上对齐到最近符合条件的对齐地址处）
5. CAS是一个原子操作，表示的是比较和交换，检查是否等于预期值，如果等于就交换，否则失败。其中比较和交换两个步骤是不可分割的，是原子性的。CAS会出现ABA问题（值从A->B->A，CAS会误判为未变化，可能导致不一致）、活锁问题（高并发下频繁CAS失败会导致一直重试，造成cpu开销较大），CAS是无锁的，线程不会阻塞，但是实现复杂度比加锁高，需要处理ABA问题等
6. 实现共享资源无锁：原子操作，保证多个线程并发访问时，数据的一致性和线程安全
7. 环形队列的无锁并发（单生产者和单消费者）：环形队列可以无锁，因为生产者和消费者各自是不同的指针（head和tail），不会修改同一位置。如果是多生产者和多消费者就必须使用原子操作才能实现线程安全
8. 如何设计一个支持不同平台的软件：让业务逻辑核心尽可能保持平台无关，而将与平台交互部分隔离到单独模块中
   * 分离业务逻辑和平台相关代码：核心层（与平台无关）、平台适配层（平台的上层抽象接口）、平台实现层