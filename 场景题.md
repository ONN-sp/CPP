1. 如何排查线上问题？
    * F12打开开发工具，看一下是不是前端问题，比如如果接口响应返回了，但是页面没显示。总之，就是看对应的接口（自己后端提供的接口）是不是正常的，返回的数据是不是正常
    * 查看线上日志
    * 测试环境复现生产环境场景
    * debug打日志
2. SQL如何优化（查询优化）？
   * 避免使用select *： 不会走覆盖索引，会有大量的回表
   * 小表驱动大表：以小表数据集为条件查询更快，对于in、exist关键字
   * 批量操作：可以避免多次请求数据库，而是合成后再批量操作
   * 多用limit：对于有些只需查找前面几条，比如排序前几条的，此时最好用limit，不然会查整张表（用了limit，再查找到指定数量的行后就会停止扫描了）
3. 分库分表是什么，为什么要这样？
   
4. 怎么设计高并发系统？
    * 系统拆分：单体->微服务
    * 缓存加速：可以用redis
    * MQ削峰：kafka
    * 数据分离：考虑分库分表，分库就是解决数据库连接数太多，性能不好的问题
    * 读写分离：主从库，主库用于写，从库用于读，使主库压力减小
    * 服务监控：Prothemus+Grafana
5. kafka用于削峰的流程？
   以电商抢购活动为例：
   * 瞬间可能有100万用户点击“立即购买”按钮，如果没有kafka，那么100万个请求会直接打到后端的服务，造成服务崩溃；
   * 引入kafka后，前端服务不会创建订单，而是将下单信息直接写到kafka的topic中（kafka自身的写入是非常快的），一旦消息写入kafka，后端的服务为kafka消费者，它会以自己能够承受的速度从kafka中消费消息，从而不会让后端服务挂掉
6. 某个网站(Web)响应很慢，可能有什么原因，怎么排查问题
   * 网络问题
     - `DNS`解析慢：`dig`看解析耗时
     - 网络延迟或丢包:`ping`,丢包>1%就值得就一步考究
     - 带宽不足(尤其是大文件传输)
     - `TLS`握手耗时过长:可能证书颁发慢
   * 服务器资源瓶颈
     - `CPU`负载高(代码死循环等):`top`指令检测
     - 磁盘IO瓶颈：`iostat`命令
     - 内存不足:`free`查看
     - 网络连接数超限:`ss`命令
   * 数据库性能问题
     - 慢查询日志：可能是全表扫描
     - 缓存失效(如`Redis`未命中,就会穿透到数据库进行较慢的访问)
   * 代码问题
     - 低效算法
     - 阻塞式IO调用   
7. `TCP`和`UDP`进行100MB数据传输时的大致过程
    * `TCP`:
        - 三次握手建立连接
        - 数据传输:
            * 数据分段:按最大报文段长度MSS进行数据分段,再给每个数据段加上源端口、目标端口、序号、确认号等
            * 可靠传输:确认+重传
            * 流量控制+拥塞控制
        - 数据接收:`TCP`在接收数据时是按序接收的,会根据数据段中的序号对数据进行排序,如果接收方接收到了乱序的数据段,那么它也会重组有序后才传给应用层.`TCP`对于丢包会进行重传,以此保证可靠传输的接收
        - 四次挥手断开连接
    * `UDP`:
        - 数据封装和发送:`UDP`不像`TCP`那样需要建立连接,发送端可以直接将100MB数据进行封装.它会将数据分成多个较小的`UDP`数据包(通常是根据网络层的`MTU`来确定每个`UDP`数据报的大小)
        - 数据传输:`UDP`没有确认和重传,所以不能保证数据一定能够成功到达,而且数据报会出现乱序到达的情况
        - 数据接收:服务端的`UDP`应用程序会接收`UDP`数据报.服务端接收到的数据可能不完整,并且可能乱序,因此需要上层应用,即业务层进行处理,如对于乱序处理,可以为每个`UDP`数据报添加一个序号,接收方在应用层按照序号对数据报进行排序即可  
        - `UDP`丢包在应用层的处理办法(下面方法是在应用层实现的)
            * `FEC`前向纠错:发送方添加冗余数据包(如:通过异或运算生成冗余包,可恢复单个丢失包),接收方通过冗余信息恢复丢失的原始数据包
            * 序号+选择性重传(更佳):
                - 序号:发送方的每个`UDP`数据包添加唯一序号
                - 确认:接收方在收到数据包后会向发送方发送确认消息  
                - 计时器:发送方在发送数据包后会启动一个计时器,如果在计时器超时之前没有收到接收方的确认,那么就要重传
                - 重传计数:可以限制重传计数,以免无限重传浪费资源 
8.  生产环境服务器变慢，如何诊断处理？
   * 先全局看，看cpu是否打满（top -h）；内存是否耗尽（free）；磁盘IO操作是否拉满；是否是网络问题
   * 根据各个瓶颈进一步分析：
    - top+火焰图
    - 分析内存占用情况，也可以直接用火焰图
    - 看哪些进程在大量的IO操作
    - ping查看丢包情况，ss查看网络连接数等
   * 最后再从日志看  
9.  服务器出现大量`CLOSE_WAIT`状态是为什么?怎么解决?
   `close_wait`状态是`TCP`四次挥手的时候服务端收到客户端的`FIN`后自己发送`ACK`出现的,服务器出现大量`close_wait`的原因有两种:
   * 服务器内部业务处理占用了极长时间,都没能处理完业务，而主动发送FIN报文；
   * 也有可能是服务器发送数据时阻塞了，即业务线程阻塞了，导致无法主动发送FIN来关闭;
   * 或者服务器自身的业务逻辑有问题,没有执行`close()`方法(即服务端没有发生`FIN`报文)
   * 解决方法:
     - 停止应用程序
     - 修改程序里的bug