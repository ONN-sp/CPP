1. `static_cast`比`C`语言中的转换更加安全;更加直接明显,可读性好
2. 回调函数:当发生某种事件时,系统或其它函数将会自动调用定义的一段函数,即回调函数.回调函数的作用:它可以把调用者和被调用者分开,调用者不关心谁是被调用者,它只需指定存在一个具有某种特定原型、某些限制条件的被调用函数
3. 一致性哈希是一种哈希算法,就是在移除或者增加一个节点时,能够尽可能小的改变已存在`key-value`的映射关系.在分布式系统中,它将对象和服务器都映射到一个哈希环上.哈希环是按照顺时针方向组织的,每个服务器节点都有一个对应的哈希值,落在哈希环的某个位置上.当存储一个对象时,通过哈希函数计算出对象的哈希值,然后再哈希环上找到顺时针方向遇到的第一个服务器节点来存储对象
4. 静态链接和动态链接
   * 静态链接:程序在编译过程中就把用到的库函数代码全部复制到可执行文件中.静态链接在执行的时候速度快;但是,空间浪费,因为如果多个程序对同一个库函数都有依赖,那么会有多个副本;更新困难:每当库函数的代码修改了,这个时候就需要重新进行编译链接形成可执行程序
   * 动态链接:程序在编译时不把库函数代码加入可执行文件中,而是在程序运行时才去加载所需的库函数代码.动态链接不会有多个副本,而是多个程序共享同一副本;更新方便:更新时只需要替换原来的库函数代码文件,而无需将所有的程序再重新链接一遍;因为链接过程在程序运行时,所以性能有一定损失
5. 友元函数和友元类
   * 友元函数:友元函数是定义在类外的普通函数,不属于任何类,可以访问其它类的私有成员/保护成员,但是需要在类的定义中声明所有可以访问它的友元函数.一个函数可以是多个类的友元函数,但是每个类中都要声明这个函数
   * 友元类:友元类的所有成员函数都是另一个类的友元函数,都可以访问另一个类中的私有/保护成员,但是另一个类里面要进行声明
   * 注意:
    - 友元关系不能被继承
    - 友元关系是单向的,不具有交换性
    - 友元关系不具有传递性
6. 介绍一下几种典型的锁:读写锁(可以同时读,写是互斥的);互斥锁(一次只能一个线程拥有互斥锁,其它线程只有等待);条件变量(互斥锁是线程间互斥的机制,条件变量是同步机制);自旋锁
7. `delete`和`delete[]`的区别
   * `delete`只调用一次析构函数
   * `delete[]`会调用数组中每个元素的析构函数
8. 为什么不把所有的函数写成内联函数?
   内联函数以代码量为代价,它可以省去函数调用的开销来提高执行效率.内联函数会将函数体直接插入每个调用点,如果函数体较大或频繁调用,会导致生成的机器代码体积显著增加,即代码膨胀.代码膨胀会造成缓存效率降低,拖慢程序
9. 为什么`C++`没有垃圾回收机制?
    实现一个垃圾回收会带来额外的空间和时间开销,对于某些底层的操作不太适合.而`C++`中也提供了类似的垃圾回收机制-`RAII`机制