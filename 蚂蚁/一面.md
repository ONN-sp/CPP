1. 总结一些`leveldb`和`redis`的不同?
   * 核心架构:LevelDB是一个嵌入式存储引擎，无独立服务进程，无网络层；Redis是独立内存数据库，通过网络协议提供C/S服务
   * 性能特点:
     - 写入性能:LevelDB适合写密集型的应用，因为它使用了LSM树结构，能够高效地处理写入操作。而Redis由于数据存储在内存中，写入速度也非常快，但在处理大量数据时可能会受到内存限制.在主从模式中,写操作主要集中在单个主节点上,这会导致主节点的写入压力较大,而且数据同步到从节点也需要一定的时间和资源,这也会限制写操作的性能
   * 数据结构:LevelDB只支持简单的键值对存储;Redis支持丰富的数据结构，如字符串、哈希、列表、集合和有序集合等
   * 持久化:LevelDB天然支持持久化，数据默认存储在磁盘上;Redis需要额外配置以确保数据持久化，它支持RDB（快照）和AOF（Append-Only File）两种持久化方式
   * 扩展性:LevelDB本身是一个单机的键值存储系统，如果需要实现分布式存储，需要借助额外的组件;Redis支持主从复制和分片集群来实现分布式部署,通过集群模式，Redis可以实现高可用性和水平扩展，以应对大规模数据和高并发访问的需求
2. `leveldb`在什么场景应用?`Redis`在什么场景应用?
   * LevelDB：只是一个本地库，无网络,使用LSM树写入磁盘，因此适用于本地、顺序写、轻量、持久化的一个场景，比如嵌入式引擎、日志存储等
   * Redis：Redis基于内存，提供微秒级响应和丰富数据结构（如集合、哈希），适合实时缓存、排行榜、分布式锁等场景
3. `deepseek`底层架构基于`Transformer`架构,包括:混合专家(`MoE`)架构、多头潜在注意力(`MLA`)架构、多`Token`预测训练目标(`MTP`)
4. `Transformer`架构?
   * Transformer由编码器（Encoder）和解码器（Decoder）两部分组成。编码器负责将输入序列转换为连续的表示，解码器则根据编码器的输出生成目标序列
   * 多头注意力机制是Transformer的核心创新。多头注意力机制允许模型在不同的表示子空间中并行地关注输入序列中不同位置之间的关系，从而更好地捕捉序列中的长期依赖和语义信息
   * 在编码器和解码器的每个块中，除了多头注意力机制外，还包含一个前馈神经网络(其中应用了Resnet网络中的残差连接)。这个网络对每个位置的表示进行变换，进一步增强模型的表达能力
5. `LevelDB`的日志恢复过程?
   `LevelDB`的恢复过程主要有`version`和内存数据的两种恢复,`version`的恢复过程为:
    * 利用Current文件读取最近使用的manifest文件；
    * 创建一个空的version，并利用manifest文件中的session record依次作apply操作，还原出一个最新的version，注意manifest的第一条session record是一个version的快照，后续的session record记录的都是增量的变化；
    * 将非current文件指向的其他过期的manifest文件删除；
    * 将新建的version作为当前数据库的version;
   Memtable 数据的丢失：Memtable 是内存中的数据结构，掉电或崩溃后，Memtable 中的数据会丢失.在写入数据时，LevelDB会先将数据写入日志文件（WAL），然后再写入 Memtable 。如果在写入 Memtable 后、数据持久化到 SSTable 之前发生掉电或崩溃，Memtable 中的数据会丢失，但日志文件中仍然保留了这些数据其内存数据的恢复过程:
    * 扫描日志文件：LevelDB会扫描所有未处理的日志文件，找到其中的写操作记录。
    * 重放日志记录：将日志文件中的写操作重新应用到一个新的 Memtable 中。如果日志文件中的数据量较大，可能会触发 Memtable 的`Compaction`操作，生成新的 SSTable 文件。
    * 更新版本信息：在恢复过程中，LevelDB会更新版本信息（Version），确保数据库的状态与日志文件中的记录一致
6. `LevelDB`的`Compaction`过程?
   * `Minor Compaction`:将内存中的`MemTable`持久化为`SSTable`文件到`Level 0`(参数`write_buffer_size`控制`MemTable`大小,`max_write_buffer_number`控制内存中最多保留的`Immutable MemTable`数量),`Level 0`的`SSTable`文件允许键范围重叠(但是单个文件的键是有序的),因此查询`Level 0`需检查所有文件,这是`LevelDB`写入快但读取相对慢的原因之一
    * `Major Compaction'`:(跨层合并)这是对磁盘上的`SSTable`文件进行合并的过程,主要目的是减少文件数量、清理冗余数据,并提升查询效率.可以分为`size Compaction`、`seek Compaction`和`manual Compaction`:
      - `size Compaction`:当某一层(如`Level L`)的数据总量超过预设阈值时,触发跨层合并,如:
         * `Level 0`的文件数量超过配置阈值(默认4个),此时的`compaction_score_`会大于等于1,则触发一次`Compaction`,并与`Level 1`中键范围重叠的`SST`文件合并,生成新的`SST`文件并写入`Level 1`,同时删除旧文件
         * `Level L(L≥1)`的数据大小超过其目标容量(如`Level 1`为10MB,`Level 2`为100MB等) 
      - `seek Compaction`:当某个`SSTable`文件因频繁查询未命中(可能包含大量已删除或过期数据)时触发.每个`SSTable`有一个`allowed_seeks`计数器,初始值为文件大小`/16KB`,每次未命中查询会减少该值,归零时触发合并(`allowed_seeks`是每个文件允许的最大无效读取次数),将被标记的`SST`文件与下一层重叠的文件合并,清理上一层的无效数据
      - `Manual Compaction`:手动紧凑化,`LevelDB`确实支持通过`CompactRange()`方法手动触发紧凑化,合并不同层级的`SSTable`以减少冗余数据,并提升查询效率
7. `MongoDB`和`LevelDB`的不同(`MongoDB`也是存储在磁盘的)
   * 数据模型:
      - `MongoDB`面向文档的数据库，支持独立服务端和分布式架构
      - `LevelDB`键值对存储的存储引擎，以库形式集成到应用中，单进程嵌入式设计，无网络层，仅支持本地访问
   * 查询能力:
      -  `MongoDB`提供强大的查询语言，支持复杂查询、聚合、全文搜索和地理空间查询
      -  `LevelDB`支持简单查找，按键或按键范围检索
   * 扩展性:
      -  `MongoDB`支持水平扩展（分片），适用于大数据和高并发场景
      -  `LevelDB`主要是单机使用，不支持水平扩展
   * 应用场景:
      - `MongoDB`Web应用、实时分析(支持强大的查询和聚合功能，能够实时处理和分析大量数据)、大数据场景(通过分片实现水平扩展，能够存储和管理海量数据)、需要灵活数据结构和复杂查询的场景
      - `LevelDB`嵌入式存储、本地存储、写密集型应用   
8. 讲述一下跳表结构?为什么要用跳表?
   `SkipList`是一个多层有序链表结构,通过在每个节点中保存多个指向其它节点的指针,将有序链表平均的复杂度`O(N)`降低到`O(logN)`.平衡树是一种非常复杂的数据结构,为了维持树结构的平衡,获取稳定的查询效率,平衡树每次插入可能会涉及到较为复杂的节点旋转等操作.作者设计跳表的目的就是借助概率平衡,来构建一个快速且简单的数据结构,取代平衡树
   跳表结构实现:跳表是一种基于概率平衡的多层索引数据结构，通过增加节点指针来加快查找速度，查找过程从最高层开始，逐层向下进行，直到在最底层找到目标节点。跳表的每一层都是一个有序链表，最底层包含所有元素，上层是下层的稀疏索引。查找时，从最高层开始向右查找，如果当前节点的下一个节点的键小于目标键，则继续向右；否则，向下一层查找。通过这种方式，跳表能够在O(logN)的时间复杂度内完成查找操作。
   为什么要用跳表结构:
   * 保证有序,有序是为了在数据存储和检索过程中提供高效的性能和便捷的操作,二分查找(时间复杂度为O(logN))比普通查找效率高多了
   * 高效查找：跳表通过多层索引结构，使得查找操作可以在O(logN)的时间复杂度内完成，类似于二分查找的效率
   * 高效插入和删除：跳表在插入和删除操作时，只需要在每一层的局部进行调整，无需像平衡树那样进行全局结构调整，因此插入和删除操作的时间复杂度也是O(logN)
   * 简单实现：相比平衡树等复杂的数据结构，跳表的实现相对简单，易于理解和维护


   