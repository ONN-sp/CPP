1. `map、set`是怎么实现的,为什么使用红黑树?
   它们底层是利用红黑树实现的.因为`map`和`set`要求是自动排序的,红黑树能够实现这一功能,而且时间复杂度比较低
2. `unordered_map`底层是哈希表,它是无序的;`map`底层是红黑树,它是有序的
3. `vector`下标访问时不会做边界检查(虽然不会报错，但是越界访问到没有预先定义的元素可能会导致后面程序崩溃),`at()`会边界检查;`erase`只能删除内容,不能改变容量大小
4. `map`的`[]`和`find`的区别?
   `[]`时,如果不存在该关键码,就会将一个具有该关键码和值类型的默认值的项插入这个`map`;`find`找不到的话会返回尾迭代器
5. `STL`包括了:算法、容器和迭代器
6. `trivial destructor`一般是指用户没有自定义析构函数,而由系统生成的
7. 智能指针是`RAII`最具代表的实现,使用智能指针,可以实现自动的内存管理
8. `++i`返回一个引用,不会产生临时对象;`i++`返回一个对象,会产生临时对象
9. `STL`中的哈希表使用的是链表法解决哈希冲突问题
10. `STL`的两级空间配置器:频繁分配/释放小内存块会导致内存碎片,降低内存利用率,因此设计了两级配置器.当开辟内存<=128字节时,则调用二级空间配置器(通过内存池和自由链表管理小块内存);如果大于128字节则转去一级配置器
11. `emplace_back`和`push_back`的不同:
    * 对象构造方式
      - `push_back`会先构造一个临时对象,再拷贝或移动到容器中
      - `emplace_back`是直接在容器中构造对象,没有临时对象,没有拷贝或移动
    * 性能:`emplace_back`更高效  
12. std::map本身不是线程安全的，也就是不能同时有多个线程修改同一个map实例，这会导致数据竞争。也不能在一个线程修改的同时，另一个线程读取它。要让他线程安全需要加锁。c++标准库的容器本身都不是线程安全的，需要外部有同步机制