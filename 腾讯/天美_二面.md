1. 访问一个网页的全过程
    * 从用户输入网址开始:用户在浏览器的地址栏中输入`URL`
    * 浏览器解析`URL`:`DNS`查询,返回该域名对应的`ip`
    * 建立`TCP`连接:三次握手
    * 发生`HTTP`请求
    * 服务器处理请求并返回响应
    * 浏览器接收响应并渲染网页
    * 连接关闭(或保持连接)
2. `TCP`和`UDP`进行100MB数据传输时的大致过程
    * `TCP`:
        - 三次握手建立连接
        - 数据传输:
            * 数据分段:按最大报文段长度MSS进行数据分段,再给每个数据段加上源端口、目标端口、序号、确认号等
            * 可靠传输:确认+重传
            * 流量控制+拥塞控制
        - 数据接收:`TCP`在接收数据时是按序接收的,会根据数据段中的序号对数据进行排序,如果接收方接收到了乱序的数据段,那么它也会重组有序后才传给应用层.`TCP`对于丢包会进行重传,以此保证可靠传输的接收
        - 四次挥手断开连接
    * `UDP`:
        - 数据封装和发送:`UDP`不像`TCP`那样需要建立连接,发送端可以直接将100MB数据进行封装.它会将数据分成多个较小的`UDP`数据包(通常是根据网络层的`MTU`来确定每个`UDP`数据报的大小)
        - 数据传输:`UDP`没有确认和重传,所以不能保证数据一定能够成功到达,而且数据报会出现乱序到达的情况
        - 数据接收:服务端的`UDP`应用程序会接收`UDP`数据报.服务端接收到的数据可能不完整,并且可能乱序,因此需要上层应用,即业务层进行处理,如对于乱序处理,可以为每个`UDP`数据报添加一个序号,接收方在应用层按照序号对数据报进行排序即可  
        - `UDP`丢包在应用层的处理办法(下面方法是在应用层实现的)
            * `FEC`前向纠错:发送方添加冗余数据包(如:通过异或运算生成冗余包,可恢复单个丢失包),接收方通过冗余信息恢复丢失的原始数据包
            * 序号+选择性重传(更佳):
                - 序号:发送方的每个`UDP`数据包添加唯一序号
                - 确认:接收方在收到数据包后会向发送方发送确认消息  
                - 计时器:发送方在发送数据包后会启动一个计时器,如果在计时器超时之前没有收到接收方的确认,那么就要重传
                - 重传计数:可以限制重传计数,以免无限重传浪费资源 
3. 介绍`RapidJSON`项目

4. 介绍`RapidJSON`项目的自定义内存分配器
   * 内存池存储结构
     - MemoryPoolAllocator 内部使用一个单向链表来存储分配的内存块(`ptmalloc`是用空闲链表`bins`管理的,`bins`上有`unsorted bins`、`small bins`、`large bins`来管理不同大小的`chunk`).每个内存块都有一个头部`ChunkHeader`结构体来记录其容量和已分配的内存大小以及指向下一个内存块的指针
     - 当用户请求分配内存时，首先尝试从当前内存缓冲区进行分配，若缓冲区空间不足，则从内存池中获取新的内存块来扩展缓冲区
   * 内存分配策略
     - 当用户调用 Malloc 或 Realloc 函数请求内存时，MemoryPoolAllocator 会优先检查当前内存缓冲区是否足够容纳请求的内存大小。如果足够，则直接从缓冲区中划分出一块内存分配给用户;如果当前缓冲区空间不足，MemoryPoolAllocator 会从内存池链表中取下一个内存块，并将其添加到当前缓冲区的末尾，从而扩展缓冲区的大小。然后在扩展后的缓冲区中分配内存
   * 内存释放机制
     - MemoryPoolAllocator 不会主动释放分配的内存。这是为了减少频繁的内存分配和释放操作可能带来的性能开销和内存碎片化问题. 虽然内存不会被释放，但当用户调用 Free 函数时，MemoryPoolAllocator 会将释放的内存标记为可重用状态，后续的内存分配可以复用这些已释放的内存空间(这和`ptmalloc`的操作类似,`ptmalloc`会把回收的`chunk`放在`unsorted bins`,以备下一次快速分配内存)   
   * `MemoryPoolAllocator`与`ptmalloc`的相同和不同
     - 相同:
        * 两者均采用预分配大块内存的策略,减少直接调用系统分配函数频率
        * 均处理了内存碎片问题
        * 均利用了链表来管理内存块 
     - 不同:
        * `MemoryPoolAllocator`的`Free`实际是一个空操作(即不支持`free`单个内存块对象),即内存块的回收并不是立即执行的.相反,内存块在整个内存池分配器被销毁时才会统一释放.也就是`MemoryPoolAllocator`通常不单独释放单个对象,而是在解析完成后一次性释放整个内存池;而`ptmalloc`支持任意时刻释放单个内存块,并通过合并相邻空闲块来减少碎片
        * `MemoryPoolAllocator`是按块分配,每次分配一个连续大块内存(64KB),然后根据需求切割为小对象,然后会移动指针,并在该内存块头部记录该内存块剩余的内存大小,以此来判断下一次分配是否够,不够的话就要分配下一个大内存块;`ptmalloc`是通过不同大小的`bins`来分配,而不是在一个大块内存上去切割
        * `MemoryPoolAllocator`通过固定分配模式(如对齐分配)尽量减少内部碎片,通过批量释放减少外部碎片;`ptmalloc`通过分`bins`操作来减少内部碎片,通过合并相邻空闲内存块来减少外部碎片
