1. 协程：协作式调度的用户态线程，可用理解为一个线程里有多个协程
   * 线程调度多数是抢占式的，由操作系统内核决定何时切换，这需要复杂的上下文切换。而协程是协作式的，一个协程必须主动让出执行权，协程是用户自己来编写调度逻辑的，另一个协程才能继续执行，避免了不必要的上下文切换，它的切换效率极高
   * 协程的创建、调度和销毁完全由用户的程序或语言运行时管理，不涉及操作系统内核
   * 协程也有切换，通常只是保存/恢复少量寄存器状态和栈信息，比线程切换快很多
   * 一个进程可以有多个线程，一个线程可以有多个协程
2. 协程的不足
   * 线程可用在cpu的不同核上并行，但是无法将一个线程的多个协程分摊到多个核上
   * 协程执行中不能有阻塞操作，否则整个线程的所有协程都会被阻塞；线程如果阻塞，cpu是会自动切换到其它线程中执行的
   * 调试困难：协程的调度是隐式的，堆栈信息不如线程清晰，难排查
3. 多线程多用于CPU密集型（计算等），利用多核实现真正并行；多协程多用于IO密集型，极低的切换开销
4. 为什么muduo不用协程？
   C++11没有成熟的协程支持，C++20才正式引入协程。并且muduo将线程与cpu核心绑定，一般线程数=核心数，避免了频繁的切换