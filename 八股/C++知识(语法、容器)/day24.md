1. `int main(int argc, char* argv[])`:程序入口点,其中:</mark>
   * `argc`:一个整数,表示传递给程序的命令行参数的数量,它至少为1,因为命令行第一个参数永远是程序的名称(通常是可执行文件的路径)   `argc`不用手动传入,命令行手动传入的是`argv[1]`及后面的参数,`argc`会自动被设置
   * `argv`:一个字符指针数组,表示传递给程序的实际命令行参数.`argv[0]`是指向程序名称的字符串,`argv[1]`到`argv[argc-1]`包含了传递给程序的其它参数
2. 一个空类,默认会添加哪些函数?
   * 缺省构造函数(默认构造函数)
   * 拷贝构造函数
   * 析构函数
   * 赋值运算符
3. `C++`中标准库
   * 标准函数库:这个库是由通用的、独立的、不属于任何类的函数组成的,继承自C语言;面向对象类库:这个库是类及其相关函数的集合
   * 输入/输出IO、字符串和字符处理、数学、时间、日期和本地化、动态分配、其它、宽字符函数
   * 标准的C++ IO类、String类、数值类、STL容器类、STL算法、STL函数对象、STL迭代器、本地化库、异常处理类、杂项支持库
4. `string`、`const char*`和`char*`的转换关系
   * `string`->`const char*`:`.c_str()`
   * `const char*`->`string`:直接传入即可,`string s(c_s)`
   * `string`->`char*`:
    ```C++
    string s = "abc";
    char* c;
    const int len = s.length();
    c = new char[len+1];
    strcpy(c,s.c_str());
    ```
   * `char*`->`string`:直接传入即可,`string s(c)`
   * `const char*`->`char*`:`const_cast`也可以
    ```C++
    const char cpc = "abc";
    char* pc = new char[strlen(cpc)+1];
    strcpy(pc,cpc.c_str());
    ```  
   * `char*`->`const char*`:直接赋值即可,`const char* cpc = pc`
5. 静态绑定:绑定的是对象的静态类型,某特性(如函数依赖于对象的静态类型,发生在编译器);动态绑定:绑定的是对象的动态类型,某特性(如函数依赖于对象的动态类型,发生在运行期)
6. 如何设计一个计算仅单个子类的对象个数?
   * 为类设计一个`static`静态变量`count`作为计数器
   * 类定义结束后初始化`count`
   * 在构造函数中对`count`+1
   * 设计拷贝构造函数和赋值运算符,进行时`count`+1
   * 在析构函数中`count`-1
7. 成员初始化列表会在什么时候用到?
   * 初始化一个引用成员变量时
   * 初始化一个`const`成员变量时
   * 当调用一个基类的构造函数时,而它拥有一组参数
   * 当调用一个成员类的构造函数时,而它拥有一组参数
8. 成员初始化列表的调用过程怎样的?
   编译器会一一操作初始化列表,以适当顺序在构造函数之内安插初始化操作,并且在任何显示用户代码前.初始化列表中的顺序是由类中的成员声明顺序决定的,不是初始化列表中写的排列顺序决定的
9. 什么时候用引用作为函数参数,什么时候用指针作为函数参数?
   * 使用指针：
    - 参数可能为空
    - 需要重新绑定或操作指针本身
   * 其余情况都是优先考虑引用作为函数参数
10.     