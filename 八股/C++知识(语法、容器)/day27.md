1. `C++`的多态怎么实现:
   * 函数重载+模板(编译时多态)
   ```C++
   // 模板函数，用于打印不同类型的数据
   template <typename T>
   void print(const T& value) {
      cout << value << endl;
   }
   // 重载模板函数，用于打印字符串
   void print(const string& value) {
      cout << "String: " << value << endl;
   }
   // 重载模板函数，用于打印布尔值
   void print(bool value) {
      cout << (value ? "True" : "False") << endl;
   } 
   ```
   * 虚函数+继承(运行时多态)
2. 对于运行时多态一般是用基类指针来访问的,即基类指针主要用于多态场景(注意:不能用基类指针来访问子类新增的成员(变量或函数),必须基类也要有).如:
   ```C++
   // 基类
   class Animal {
   public:
      virtual void makeSound() {
         cout << "动物发出声音" << endl;
      }
   };
   // 子类1
   class Dog : public Animal {
   public:
      void makeSound() override {
         cout << "汪汪汪" << endl;
      }
   };
   // 子类2
   class Cat : public Animal {
   public:
      void makeSound() override {
         cout << "喵喵喵" << endl;
      }
   };
   int main() {
      Animal* animal1 = new Dog();
      Animal* animal2 = new Cat();
      animal1->makeSound(); // 输出 "汪汪汪"
      animal2->makeSound(); // 输出 "喵喵喵"
      delete animal1;
      delete animal2;
      return 0;
   }
   ```
3. `C++`中,类实例化后的对象主要为非静态成员变量分配内存,而静态成员变量(静态存储区)和成员函数(代码区).非静态成员变量存储在对象的内存空间中
4. 多态的底层原理:
   * 在编译阶段,编译器在发现基类中有虚函数时,会自动为每个含有虚函数的类生成一份虚表(虚函数表),该表是一个一维数组,虚表里保存了虚函数的入口地址
   * 编译器会在每个对象的前四个字节(32位系统)中保存一个虚表指针(要证明它确实存在可以利用`sizeof(类对象)`)(虚表指针存在每个对象的开头4字节中),执行对象所属类的虚表.在构造时(注意:虚表指针是在运行时类实例化时才会有),根据对象的类型去初始化虚表指针`vptr`,从而让`vptr`指向正确的虚表,从而在调用虚函数时,能找到正确的函数(虚表指针是类的非静态成员变量)
   * 派生类在编译阶段会构建自己的虚表,虚表中包含了对基类的重写(`override`),也包含了自己新增的虚函数.在派生类定义对象时程序运行会自动调用构造函数,在构造函数中对虚表初始化.在构造子类对象时,会先调用父类的构造函数.此时,编译器只看到了父类,并为父类对象初始化虚表指针,令它指向父类的虚表;当调用子类的构造函数时,为子类对象初始化虚表指针,令它指向子类的虚表
   * 当派生类对基类的虚函数没有重写时,派生类的虚表指针指向的是基类的虚表;当派生类对基类的虚函数重写时,派生类的虚表指针指向的是自身的虚表;当派生类中有字节的虚函数时,会在自己的虚表中将此虚函数地址添加在后面
   这样指向派生类的基类指针在运行时,就可以根据派生类对虚函数重写情况动态的进行调用,从而实现运行时多态 
5. 一个类的虚函数表只会有一份,就算这个类实例了很多对象,它们也是共享一个虚表的
6. 构造函数不能是虚函数:虚函数对应一个虚函数表,类中存储一个虚表指针指向这个虚函数表.如果构造函数是虚函数,就需要通过虚表指针调用,可是对象没有初始化就没有虚表指针,无法找到虚函数表,所以构造函数不能是虚函数
7. `C++`中虚函数表位于可执行文件的只读数据段,也就是`C++`内存模型的常量区;而虚函数位于代码段
8. 构造函数可以重载,析构函数不能重载,一个类只能有一个析构函数,且不能指定参数
9. 析构函数的作用:与构造函数的作用相反,用于撤销对象的一些特殊任务处理,可以是释放对象分配的内存空间.析构函数没有参数,也没有返回值,而且不能重载,在一个类中只能有一个析构函数
10. `C++`可以定义空类,空类大小为1字节
11. 成员函数和普通函数的区别
    * 成员函数是定义在类内部的函数，它属于类的一部分，与类的对象相关联;普通函数是在类外部定义的独立函数，不属于任何类
    * 成员函数是类的组成部分，能够直接访问类中的其他成员（包括私有成员），这体现了封装的特点;普通函数与类没有直接的从属关系，不能直接访问类的成员，除非通过对象或者友元等方式
    * 成员函数的调用会隐式地传递一个指向调用该函数的对象的指针(`this`指针),通过这个指针可以访问对象的数据成员和成员函数
12. `C++`的类的成员函数的调用会隐式地传递一个指向调用该函数的对象的指针(`this`指针)
13. `C++`的多继承