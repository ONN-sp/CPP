1. 协程：协作式调度的用户态线程，可用理解为一个线程里有多个协程
   * 线程调度多数是抢占式的，由操作系统内核决定何时切换，这需要复杂的上下文切换。而协程是协作式的，协程是用户自己来编写调度逻辑的，另一个协程才能继续执行，避免了不必要的上下文切换（没有用户态和内核态间的切换），它的切换效率极高
   * 协程的创建、调度和销毁完全由用户的程序或语言运行时管理，不涉及操作系统内核
   * 协程也有切换，通常只是保存/恢复少量寄存器状态和栈信息，比线程切换快很多
   * 一个进程可以有多个线程，一个线程可以有多个协程
2. 协程的不足
   * 线程可用在cpu的不同核上并行，但是无法将一个线程的多个协程分摊到多个核上
   * 协程执行中不能有阻塞操作，否则整个线程的所有协程都会被阻塞（因为协程不会有内核态自动切换机制）；线程如果阻塞，cpu是会自动切换到其它线程中执行的
   * 调试困难：协程的调度是隐式的，堆栈信息不如线程清晰，难排查
3. 多线程多用于CPU密集型（计算等），利用多核实现真正并行；多协程多用于IO密集型，极低的切换开销
4. 为什么muduo不用协程？
   C++11没有成熟的协程支持，C++20才正式引入协程。并且muduo将线程与cpu核心绑定，一般工作子线程数=核心数，避免了频繁的切换
5. 使用原子操作通常是需要保护的共享数据是一个简单的整数或指针，而不是一大段代码（临界区）或复杂度数据结构，原子操作可能会引起不好调试的并发bug。只有当性能分析（Profiling）明确显示互斥锁成为系统瓶颈时，才考虑使用原子操作来优化特定的、简单的计数器或标志位。原子操作性能更好的原因是：它没有了耗时的上下文切换过程
6. 一般上下文切换是由系统调用或中断触发，此时会伴随着用户态到内核态的切换