1. 模板经过编译后变成怎样？
   变成了用具体类型替换模板参数后的函数、结构体、类实例，其实就是模板实例化后得到的
2. 内存对齐的原因：对齐操作在计算机系统中非常重要,特别是在处理器访问内存时.处理器从内存读取数据时,通常是按块进行的,最常见的是按4字节(32位)或8字节(64位)读取.对齐的内存访问可以使得处理器只需要一次内存访问即可读取完整的数据,而不对齐的访问可能会导致处理器需要进行两次内存读取.如果数据没有对齐到合适的边界,处理器需要进行两次或更多次内存读取,将结果合并后才能得到所需的数据,这会增加延迟并降低性能
3. 右值引用(右值引用不能绑定到左值)：右值引用是一种专门用于绑定到右值的引用类型,语法是`T&&`.可以延迟临时对象的生命周期,`string &&c=string("hello");;// 此时就把string("hello")临时对象延长了，如果不用右值引用那么临时对象在这一句后就立即销毁`。其核心应用：
   * 实现移动语义:允许我们将资源从一个对象移动到另一个对象，而不是拷贝，更高效。此时对于类来说，其构造函数和赋值运算符的参数就可以是右值引用，在传入右值时调用的就是移动构造函数或移动赋值函数，而不是拷贝构造和拷贝赋值
   * 实现完美转发：在函数模板中当使用右值引用作为模板参数时,可以根据实参的类型来推导出参数类型是左值引用还是右值引用,然后保持其原有类型(是左值就转发为左值引用被模板收到，是右值就转发为右值引用被模板收到)转发，此时一般是要和`std::forward`一起使用
4. 怎么实现内存起始对齐：不满足对齐时，编译器会插入填充字节，把结构体或变量的起始地址垫到满足对齐要求的位置（比如向上对齐到最近符合条件的对齐地址处）
5. CAS是一个原子操作，表示的是比较和交换，检查是否等于预期值，如果等于就交换，否则失败。其中比较和交换两个步骤是不可分割的，是原子性的。CAS会出现ABA问题（值从A->B->A，CAS会误判为未变化，可能导致不一致）、活锁问题（高并发下频繁CAS失败会导致一直重试，造成cpu开销较大），CAS是无锁的，线程不会阻塞，但是实现复杂度比加锁高，需要处理ABA问题等
6. 实现共享资源无锁：原子操作，保证多个线程并发访问时，数据的一致性和线程安全
7. 环形队列的无锁并发（单生产者和单消费者）：环形队列可以无锁，因为生产者和消费者各自是不同的指针（head和tail），不会修改同一位置，此时也不需要原子操作。如果是多生产者和多消费者就必须使用原子操作才能实现线程安全：生产者不能直接移动写指针，它必须通过一个CAS操作“原子地”抢占当前写指针的位置，如果这个指针位置已经被其它线程抢占过了，那么这个线程就会CAS重试。只有抢占成功的生产者，才有权在指定的位置写入数据，消费者也同理。代码如下：
   ```C++
   bool enqueue(const T& item) {
      size_t current_head;
      size_t current_tail;
      size_t next_head;
      // CAS 循环：尝试抢占一个写入位置
      do {
         // 1. 获取当前的写指针和读指针
         current_head = head_.load(std::memory_order_relaxed); // 这个head不需要与前面事件同步，所以直接relaxed
         current_tail = tail_.load(std::memory_order_acquire); // 需要获取最新的tail
         // 2. 计算下一个写位置（注意回绕）
         next_head = (current_head + 1) % buffer_.size();
         // 3. 检查队列是否已满
         // 关键：如果下一个写位置等于当前的读位置，说明队列已满。
         if (next_head == current_tail) {
               return false; // 队列已满，入队失败
         }
         // 4. 核心：尝试原子地将 head_ 从 current_head 推进到 next_head。
         // 如果成功，说明我们成功占用了 current_head 这个位置。
         // 如果失败，说明有其他生产者抢先修改了 head_，我们需要重试整个流程。
      } while (!head_.compare_exchange_weak(
                  current_head,   // 预期值：如果head还是current_head，就执行交换
                  next_head,      // 期望设置的新值
                  std::memory_order_acq_rel, // 成功时的内存序：兼具acquire和release
                  std::memory_order_relaxed) // 失败时的内存序
               );
      // 5. CAS 成功！我们现在独占地拥有 buffer_[current_head] 的位置。
      // 将数据写入这个预留的位置。
      buffer_[current_head] = item;
      return true;
   }
   // 假设有两个生产者线程 P1 和 P2 同时尝试入队;P1 和 P2 同时进入循环;都读取 head_ = 0 (relaxed);都读取 tail_ = 0 (acquire);都计算 next_head = 1;P1 成功将 head_ 从 0 改为 1 (使用 acq_rel);P1 退出循环，写入 buffer[0] = item1;P2 尝试将 head_ 从 0 改为 1，但发现 head_ 已经是 1;CAS失败，使用 relaxed 内存序重试;P2重试：读取 head_ = 1 (relaxed)，读取 tail_ = 0 (acquire)，计算 next_head = 2，CAS成功，将 head_ 从 1 改为 2，写入 buffer[1] = item2。如果没有正确的内存序此时就可能会导致P2看不到head_已经变为1了，而它仍然尝试写入位置0，导致数据覆盖
   bool dequeue(T& item) {
      size_t current_tail;
      size_t current_head;
      size_t next_tail;
      do {
         current_tail = tail_.load(std::memory_order_relaxed);
         current_head = head_.load(std::memory_order_acquire); // 获取最新的head
         // 检查队列是否为空
         if (current_tail == current_head) {
               return false;
         }
         // 计算下一个读位置
         next_tail = (current_tail + 1) % buffer_.size();
         // 尝试原子地抢占消费 current_tail 位置的机会
      } while (!tail_.compare_exchange_weak(
                  current_tail,
                  next_tail,
                  std::memory_order_acq_rel,
                  std::memory_order_relaxed)
               );
      // CAS 成功！我们现在独占地拥有读取 buffer_[current_tail] 的权利。
      // 但我们必须检查数据是否真的写入完成了（解决上述发布问题）。
      // 如果使用序列号方案，需要等待 seq_[current_tail] == current_tail + 1
      // 从队列中取出元素
      item = buffer_[current_tail];
      return true;
   }
   ```
8. 如何设计一个支持不同平台的软件：让业务逻辑核心尽可能保持平台无关，而将与平台交互部分隔离到单独模块中
   * 分离业务逻辑和平台相关代码：核心层（与平台无关）、平台适配层（平台的上层抽象接口）、平台实现层