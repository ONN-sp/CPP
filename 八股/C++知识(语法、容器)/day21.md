1. 构造函数按参数数量和类型分：
   * 默认构造函数(无参)
   * 带参构造函数
   * 拷贝构造函数
   * 移动构造函数
2. 讲述一下`std::move()`:
   `std::move`是 C++11 引入的关键工具，用于启用移动语义，避免不必要的资源拷贝.通常情况下,当对象被传递时,会发生拷贝操作,这会涉及到分配新的内存和拷贝数据.而移动语义则允许对象的资源(如内存、文件句柄等)被“偷走”,而不需要拷贝.`std::move`的主要用途是显式地将一个左值(如一个局部变量)转换为右值,从而可以调用移动构造函数或移动赋值运算符,而不是拷贝构造函数或拷贝赋值运算符.当一个类对象被`std::move`之后,它的资源所有权被转移到另一个对象,而原对象仍然存在.原对象将会在其作用域结束时被正常析构,但此时它的资源(如内存、文件句柄等)可能已经被转移给了另一个对象,所以它可能处于一种有效但未定义状态.对于基本类型(如`int、char`等),使用`std::move`并不会带来性能提升,因为它们的复制和移动操作本质上是相同的.基本类型没有资源管理的概念,因此移动语义对基本类型没什么用
3. `std::unique_ptr`是排他所有权的,它的设计上就是为了确保资源的所有权是唯一的,不能被多个指针共享
4. `C++11`有哪些新特性:
   * `nullptr`代替`NULL`
   * 引入了`auto`和`decltype`两个关键字实现类型推导
   * 引入了基于范围的`for`循环
   * 类和结构体中的初始化列表
   * `Lambda`表达式
   * `std::forward_list`单向链表
   * 右值引用和移动语义`std::move`
   * 等等
5. `auto`:用于声明变量时让编译器自动推断其类型(其实是根据初始值来进行类型推演的);`decltype`:编译器推断表达式类型,却不进行实际的计算表达式的值;`decltype(auto)`:`C++14`新增的类型指示符,可以用来声明变量以及指示函数返回类型.在使用时它会将`=`右边的表达式替换成`auto`,然后根据`decltype`进行表达式类型推导,即此时就是`decltype`,如:`int e=4;const int* f=&e;decltype(auto) j=f;`<=>`decltype(f) j = f;`,其实`decltype(auto)`就是`decltype`的多一步处理
6. `C++`中`NULL`和`nullptr`区别:`NULL`在`C++`被当作整数0,而`nullptr`提供了一种更安全和更明确的方式来处理空指针,避免了与整数0的混淆,即`nullptr`可以明确区分整型和指针类型
7. 智能指针的原理:智能指针是一种用于管理动态分配内存的工具。在C++中，使用new运算符分配内存后，需要手动使用delete运算符释放该内存，否则可能会导致内存泄漏。智能指针的实现通常基于RAII机制。RAII机制是通过在对象的构造函数中获取资源，并在析构函数中释放资源来实现的。因此智能指针可以用于防止内存泄漏
8. 常用的智能指针:
   * `unique_ptr`(代替了`auto_ptr`(C++98用的)):排他所有权指针,多个智能指针不能共享同一个对象,不能进行普通的赋值和拷贝操作(如果允许可能会出现:双重释放、内存泄漏等问题),但可以使用`std::move`后的赋值
   * `shared_ptr`:采用引用计数方法，多个智能指针可以共享同一个对象，当计数为0的时候会自动的释放动态分配的资源,但会出现交叉引用的问题
   * `weak_ptr`:弱引用智能指针，不会增加对象的引用计数，用于避免`shared_ptr`的循环引用问题
9. 谈一谈`Lambda`函数:
    * 利用`Lambda`表达式可以编写内嵌的匿名函数,用以替换独立函数或函数对象
    * 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类，我们称为闭包类型。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块
    * `Lambda`必须使用尾置返回来指定返回类型,可以忽略参数列表和返回值,但必须永远保护捕获列表和函数体
10. 循环引用是指使用多个智能指针`shared_ptr`时,出现了指针之间相互引用,从而形成环的情况,有点类似死锁的情况,这种情况下,会导致引用计数无法归零,从而造成内存泄漏
11. 智能指针出现循环引用怎么解决?
    将其中一个`shared_ptr`改成`weak_ptr`即可，由于`weak_ptr`不会增加`shared_ptr`的引用计数，因此不会阻止对象被销毁
12. 手写实现智能指针类需要实现哪些函数?
    构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数
13. `auto_ptr`的作用
    * 主要是为了解决"有异常抛出时发生内存泄漏"的问题
    * `auto_ptr`不能管理数组
    * `auto_ptr`支持所拥有的指针类型之间的隐式类型转换
    * `auto_ptr`不能用于赋值和拷贝