1. 一个服务器进程最大支持的`TCP`连接数是多少?
   `TCP`连接本质上在内核里就是一个`socket`对象,一个`socket`对象就是一个四元组的数据结构-源IP、源端口、目标IP、目标端口.一个服务端进程,它的IP、端口是固定的,因此只有客户端可以变了,所以一个服务端进程最大能支持的`TCP`连接个数=客户端`IP`数*客户端的端口数,对于`IPv4`,客户端的`IP`数最多有2^32,客户端的端口数最多为2^16,即一个服务端进程最大能支持的`TCP`连接个数=2^48.但是,服务端的进程最大能支持的`TCP`连接数不能达到理论上限,因为会受到文件描述符、内存大小资源的限制
2. 一台服务器最大最多能支持多少条`TCP`连接?
   一条静止的`TCP`连接(不发送数据、不接收数据)占用的大小(一个`TCP`对象占用的大小等于它所包含的一些数据结构占用大小的总和)是3.44KB=0.81KB+2.19KB+0.19KB+0.25KB,因此只考虑静态状态的`TCP`时,8GB物理内存的服务器最大能支持`TCP`连接数=8GB/3.44KB=2438956(约240万)
3. `bind、listen、accept、connect`等函数是用户态程序调用的库函数,但是他们都会触发系统调用,进入内核态。在用户代码里调用后，CPU 必须从用户态切换到内核态，由内核里的 TCP/IP 协议栈完成真正的操作，在大多数情况一次系统调用就会触发一次完整的用户态→内核态→用户态的往返
4. 服务端调用`listen`后`sleep`休眠,客户端的`connect`能成功吗?三次握手能成功吗?
   `sleep`只会让当前用户态进程进入休眠状态,不会影响内核的运行.在操作系统中,内核负责管理网络协议栈,包括`TCP`协议的实现,因此服务端`sleep`后不会影响后续的三次握手环节,此时会将三次握手完成的`TCP`连接放到全连接队列,等待后续服务端调用`accept`来获取连接
5. `accept`是在三次握手之后调用的,它接收的就是三次握手成功后放入`TCP`全连接队列中的`TCP`连接
6. `listen(fd, 128)`:让 fd 进入监听状态，并且最多允许 128 个尚未被 accept() 取走的连接在队列里排队，这是全连接队列，listen得到的是全连接队列
7. TCP三次握手是在listen()之后、accept()之前完成的
8. 半连接队列：客户端第一次SYN后服务器发送ACK后服务端的状态，此时三次握手未完成；全连接队列： 三次握手已完成、等待服务器 accept() 取走的连接队列
9. websocket是应用层的协议，只要是针对于需要服务器主动、实时、高效地向客户端推送数据的场景。原本的HHTP是“一问一答”的方式，客户端永远是对话的发起者，服务的永远是被动的响应者，此时主要是采用HTTP轮询（客户端定期向服务端发送HTTP请求，询问是否有新的数据，从而看是不是需要推送）或HTTP长轮询（长轮询就类似长连接，不需要反复建立HTTP连接）；而Websocket提供了一个全双工、双向、单socket的持久连接，客户端和服务端都可以主动发送消息，整个通信过程只使用一个TCP连接，其优势是低开销（Websocket头部开销极小，相比于HTTP小很多），低延迟（服务端可以随时主动推送数据给客户端，无需客户端先发起请求），高效能
10. WebSocket 连接总是由客户端（如浏览器）发起。它首先会建立一个正常的 TCP 连接（三次握手），然后通过这个连接发送一个特殊的 HTTP 请求。这个请求不是普通的 GET 或 POST，而是一个要求升级协议的请求。websocket的连接建立过程也称为“握手”，客户端发送一个特殊HTTP请求（升级协议），包含Upgrade:websocket和Sec-WebSocket-Key等头部信息（它们明确告知服务器：“我想把连接从 HTTP 升级到 WebSocket）.服务端响应一个101状态码，表示协议转换成功，并返回Sec-WebSocket-Accept