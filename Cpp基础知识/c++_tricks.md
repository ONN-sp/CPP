# 2023/11/6
1. 如果要实现数组完全不浪费内存,那么就不能提前设置数组大小,也不能提前分配内存,此时必须用`vertor`对象和`string`对象
2. `vector`对象的输出不能直接对那个动态数组名进行输出(`cout`),要么输出某个元素,要么用迭代的方法遍历
3. `vector`和`string`类似,都引入了类似的很多方法,如:`s.push_back()与v.push_back()`
4. 
    ```C++
    1. 字符数组求长度=strlen(s);
    2. string对象求长度=s.size()
    ```
5. 对`vector`对象,通常不知道预先长度,因此可以不用设置长度,后面直接增添元素就行
6. `string`清空
   ```C++
   .clear()
   ```
7. `getline(cin,str)`是`string`对象的一个输入函数,它不需要提前指定大小
# 2023/11/7
1. 为了可以输入多个单词,不能使用`cin`来直接输入字符串,因为它只能输入一个单词
2. `vector`的`push_back`只能`push`对应的类型,如
   ```C++
   eg:
   vector<string> p;
   p.push_back('\0');//Error
   p.push_back("\0");//Yes
   #存储string类型的vector对象p只能push string
   ```
# 2023/11/8
1. 数组长度可以是`const`
# 2023/11/12
1. 只有字符数组/字符串才可以直接用`cin`来对数组名/字符串名进行输入,如
   ```C++
   eg:
   char str[10];
   string s;
   cin >> str;//√
   cin >> s;//√
   int a[10];
   cin >> a;//×
   //因此类似整型数组这些是不能直接通过对数组名进行输入整个数组的,只能一个元素一个元素的输入
   ```
2. <span style="color:red;">`cin`=标准输入流,它是从交互外设(键盘等)读取流,即输入流(输入缓冲区)</span>.然后按照不同读取函数(或方法)给变量赋值,如:
   ```C++
   eg:
   cin >> s;//键盘输入a b d
   //单独的cin就会把第一个空白字符前的数据a赋给s,而bc这些未读取给s的数据会被读取到输入流中.若还有输入语句cin >> s2;,那么在不清空输入流(输入缓冲区)时会直接将数据b赋给s2
   ```
3. <span style="color:red;">`cout`=标准输出流,它是向显示外设(输出窗口)写入流,即输出流(输出缓冲区)</span>
4. 需要说明的是`cin`遇到空白字符会结束获取字符串,但<span style="color:red;">他会把后面过滤的字符串存放到输入流(缓冲)中</span>,如果后面还需要输入字符串,则会从前面存放的字符串开始获取(这一点很重要)
   ```C++
   eg:
   string s1,s2;
   cin >> s1;//键盘输入:a b   c,将这些字符串(此时的输入缓冲区="a""b""c",没有空白字符,因为是cin)读取到了输入缓冲区,然后把"a"赋给了s1,此时输入缓冲区就没有"a"了
   cout << s1 << endl;//
   cin >> s2;//这里窗口是不会停留着显示输入的,因为输入缓冲区还有内容,所以不需要再输入,它会直接赋值字符串b给s2
   cout << s2 << endl;
   //注意:输入缓冲区还有内容的话,是不需要再输入的,即表现的现象就是仿佛不执行cin>>s2.但是其实是执行了的,只是执行了从输入缓冲区读取再赋值的操作
   ```
5. 在读取字符串时,当我们输入一系列字符或字符串后(包含空白字符),此时输入缓冲区可能会保留一些未读取的字符,这些未读取的内容可能会对后续的输入操作产生干扰(当数据从缓冲区读取后,缓冲区就不包括它了).因此,我们很有可能需要清空缓冲区
6. <mark>深刻理解`cin`:当我们从键盘输入字符串(以字符串为例)的时候需要敲一下回车键才能将这个字符串送入到缓冲区中,按下回车键就会刷新缓冲区.输入语句会直接从缓冲区读取数据(<<span style="color:red;">所以cin程序其实是会先读入缓冲区,再由缓冲区读数据到变量</span>>),读取一个就会在缓冲区少一个数据.若缓冲区没有被读取完,那么下一次的输入语句会直接从缓冲区读取数据,而略过第一步的从键盘输入数据到缓冲区</mark>
7. `C++`输入方式总结,空白字符=(Tab、空格、回车等)
    ```C++
    * //适合任何类型变量
    使用原始cin输入:这种输入方法会自动过滤掉(即这种情况的输入缓冲区没有空白字符)不可见字符(如:空格、回车、tab等).若不想过滤掉不可见字符,则要用noskipws流进行控制(必须逐个输入).
        eg:
        char word[10];
        char word2[10];
        for(int i=0;i<10;i++)
            cin >> noskipws >> word[i];//(√)此方法把空白字符存储到了输入缓冲区
        cin >> word2;//因为noskipws把空白字符存储到了输入缓冲区,所以这个输入语句根本不会执行,也不会给word2赋值,因为单独的cin这个语句到了空白字符就会认为结束了,所以word2根本不会赋值数据(空白数据也不会)
    * 利用cin.get()
        //C++支持函数重载的OOP特性,因此有多个不同参数列表而相同名字的函数,如:
        - int a = cin.get();//适合整型变量,函数返回值赋给int类型的a
        - cin.get(char a);//适合字符型变量,该函数返回的是istream类型(执行bool转换后为true或false).输入的字符还是会赋给字符a
        - cin.get(char a[10], 10);//适合字符数组,不适用string类型.该函数返回的也是istream类型(执行bool转换后为true或false).字符串赋给字符数组
    * cin.getline()//适合字符数组,不适用string类型
    * getline()//适合string类型,不适用字符数组
    * getchar()//适合字符型
   //其中只有单独的cin
    ```
8. `C++`输出方式总结
   ```C++
   * //适合任何类型变量
   使用原始cout输出:程序->输出缓冲区->显示屏
   * cout.put();//输出单个字符
   ```
# 2023/11/16
1. `g++`编译
   ```C++
   1. 预编译:宏替换、头文件展开、注释去掉(#include、#define、#ifndef等等)
   #只激活预处理,不会自动生成.i文件,如果需要可以通过-o生成hello.i
   eg:
   g++ -E hello.cpp [-o hello.i]//如果不输出到hello.i文件中,那么就会在终端打印
   2. 编译:将预处理后的文件转换成汇编语言,生成.s汇编文件
   #两种方式
   eg:
   * #cpp源文件直接生成.s汇编文件而不用预编译
     g++ -S hello.cpp [-o hello.s]
   * #将预处理的.i文件进行编译
     g++ -S hello.i [-o hello.s]
   3. 汇编:将汇编文件转换为目标文件(二进制机器代码),即.o文件
   eg:
   g++ -c hello.cpp [-o hello.o]//实际执行了预处理、编译、汇编(只是预处理和编译阶段隐式执行的)
   g++ -c hello.i [-o hello.o]//实际执行了编译、汇编
   g++ -c hello.s [-o hello.o]//实际只执行了汇编
   4. 链接:链接相关目标文件或动静态库等,生成可执行文件
   eg:
   g++ hello.cpp [-o hello.exe]//默认生成a.out可执行文件,实际执行了预处理、编译、汇编、链接
   g++ hello.i [-o hello.exe]//实际执行了编译、汇编、链接
   g++ hello.s [-o hello.exe]//实际执行了汇编、链接
   g++ hello.o [-o hello.exe]//实际执行了链接
   ```
# 2024/1/4
1. `cin`一些函数总结:
   ```C++
   1. cin.ignore() #常用来处理cin或cin.get()中输入缓冲区的字符(如:换行符)
   eg:
   cin.ignore(5, '\n');#表示把'\n'前的5个字符删去
   <=>
   while(cin.get()!='\n') continue;
   2. cin.clear() #重置cin标识符
   eg:
   cin.clear();
   #当我们输入错误时,如果不做任何改变,那么后续输入是不能进行的.在cin里面有个函数cin.rdstate()可以检查此时的输入标识符,返回0表示没有错,能后续继续输入;返回4,表示不能继续输入,那么此时就需要用cin.clear()进行重置cin的输入状态
   3. vscode里面的cin.sync()不是清空输入缓冲区
   ```
# 2024/1/7
1. 判断输入数据是否是数字的新方法:直接用`cin`
   ```C++
   int value;//float double等数字类型都行
   while(cin >> value)//此时输入非数字时会为类型无效,则istream对象会返回一个无效状态,即false(0)
   ...
   ```
2. `cin >>`(无`noskipws`)不会把空白字符存入输入缓冲区
   ```C++
   eg:
   cin >> ch1;
   cout << ch1 << endl;
   cin >> ch2;
   cout << ch2 << endl;
   =>输入:a b
   =>输出:  a
            b
   //cin>>会直接省略空白字符,然后把第一次输入的ab存入输入缓冲区
   eg:
   char ch[2], ch2[2], ch3[2];
   cin >> ch;
   cout << ch << endl;
   cin >> ch2;
   cout << ch2 << endl;
   cin >> ch3;
   cout << ch3 << endl;
   =>输入:a b c
   =>输出:  a
            b
            c
   //此时第一次输入后,输入缓冲区有abcd(无空白字符),但是cin使用空白字符来确定字符串结束位置,则每一次cin>>只会获取一个单词,后面不够的全部补'\0'
   =>输入:abc def ghi
   =>输出:  abc
            def
            ghi
   //此时其实是下标越界了,但是不会报错(会有警告),它的赋值只会继续按照内存赋下去,但是这样很有可能会覆盖其他数据,所以实际中不要这样操作
   ```
3. `cin >>`不会把换行符存入输入缓冲区
4. `cin.getline()`多次读取的情况
   ```C++
   eg:
    char ch[2], ch2[2];
    cin.getline(ch, 2);
    cout << ch << endl;
    //cin.clear();//处理cin.getline失效位的方法
    cin.getline(ch2, 2);
    cin >> ch2;
    cout << ch2 << endl;
   =>输入:abc
   =>输出:  a

   //cin.getline()读取时,当输入的长度超过预设字符个数,cin.getline会设置失效位,即cin.rdstate()=4,那么后续就不能继续读取到ch2了.但是第一次输入后,输入缓冲区有abc'\0'(读取换行符,并将换行符替换成'\0',并从输入缓冲区抹去).第二次的cin.getline()直接会读入一个换行符,所以输出a和换行.
   eg:
   ```