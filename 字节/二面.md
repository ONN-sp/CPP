1. shared_ptr一定是线程安全的吗？
   * 引用计数是线程安全的：这个引用计数的增加和减少是原子操作，因此是线程安全的
   * 所管理的对象不一定是线程安全的：如果多个线程通过不同的shared_ptr访问同一个对象，即共享资源，并且这些线程有可能修改该共享资源，那么就需要自行保证对该对象的访问是线程安全的，比如加锁。如:
    ```C++
    struct Counter {
        int value = 0;
    };
    void worker(std::shared_ptr<Counter> p) {
        for (int i = 0; i < 100'000; ++i) {
            ++p->value;          // 未加锁：多线程同时读写
        }
    }
    int main() {
        auto ptr = std::make_shared<Counter>();
        std::thread t1(worker, ptr);   // 拷贝 ptr，引用计数原子递增（安全）
        std::thread t2(worker, ptr);   // 同上
        t1.join();
        t2.join();
        std::cout << "Counter = " << ptr->value << '\n';  // 极大概率≠200000
    } 
    ```
2. 一个线程绑一个核，那么会发生线程切换吗?
   即使一个线程绑定到一个CPU核上，仍然可能发生线程切换.线程绑核也叫设置CPU亲和性，是指将一个线程固定分配给某个特定的CPU核心来执行，这样做可用减少缓存失效（线程的数据更可能保留再该核心的缓存中，提高性能）；避免核心间切换开销（此线程不会在多个核心之间跳跃）。绑核解决的仅仅是该线程在不同核心之间切换的问题，但在一个核心上，操作系统仍然需要管理多个线程。比如：现代操作系统都是“分时系统”，即使你的线程Thread A绑在了Core 0上，它也不会永远霸占这个核心。操作系统会给它分配一个时间片（比如10ms）。当时间片用完后，操作系统会强制进行上下文切换，把Thread A从运行状态挂起，然后让同样在Core 0上等待的另一个线程Thread B开始运行。因此，总的来说，绑核只是确保该任务线程不会在不同核心之间跳跃运行，而不能确保某个核心只运行该线程而不切换到其它线程中运行