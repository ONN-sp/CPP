1. `STL`每种容器对应的迭代器
   * `vector、deque、array`->随机访问迭代器
   * `stack、queue、priority_queue`:无
   * `list、(multi)set/map`->双向迭代器
   * `unordered_(multi)set/map、forward_list`->前向迭代器
2. `STL`容器有随机访问迭代器、双向迭代器、前向迭代器三种,支持不同的运算:
   * 前向迭代器:假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值
   * 双向迭代器:双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 --p 或者 p-- 操作（即一次向后移动一个位置）
   * 随机访问迭代器:随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：
    - p+=i：使得 p 往后移动 i 个元素
    - p-=i：使得 p 往前移动 i 个元素
    - p+i：返回 p 后面第 i 个元素的迭代器
    - p-i：返回 p 前面第 i 个元素的迭代器
    - p[i]：返回 p 后面第 i 个元素的引用
    - 两个随机访问迭代器 p1、p2 还可以用 <、>、<=、>= 运算符进行比较
    - 表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差
3. 为什么有迭代器?
   C++的STL中迭代器是非常重要的一部分。它的作用是为了将数据容器与算法分离，使得算法能够独立于具体的容器类型进行操作。迭代器是一种类似于指针的抽象数据类型，它可以遍历容器中的元素，并支持对元素进行访问、修改、删除、插入等操作。通过使用迭代器，STL可以实现很多通用的算法，例如排序、查找、复制、替换等等。迭代器的好处在于它可以抽象出访问容器中元素的过程，使得容器的实现细节对算法是透明的，从而提高了代码的可读性、可重用性和可维护性
4. `STL`中迭代器失效的情况有哪些?
   * 以vector为例：插入元素： 尾后插入：size < capacity时，首迭代器不失效尾迭代失效（不用重新分配空间）；size >= capacity时，所有迭代器均失效（需要重新分配空间）。中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后的所有迭代器失效，size >= capacity时，所有迭代器均失效。删除元素： 尾后删除：只有尾迭代失效。 中间删除：删除位置之后所有迭代失效。
   * deque 和 vector 的情况类似，而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效，erase返回下一个有效迭代器；map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器；unordered_map 迭代器意义不大, rehash之后, 迭代器应该也是全部失效
5. `STL`迭代器失效怎么办
   在C++中，当一个迭代器指向的元素被删除、添加或者修改时，这个迭代器就会失效。如果在这个迭代器失效后仍然使用它来访问容器中的元素，就会产生未定义的行为，导致程序出现错误。如果一个迭代器失效可以考虑以下几种方法来避免程序错误：1）使用新的迭代器。如果容器中的元素被删除或者添加了，就可能需要重新获得一个指向容器中正确位置的新迭代器。尽可能避免在迭代器失效的情况下修改容器中的元素。当一个元素被删除时，可以考虑将其标记为无效而不是直接删除，这样就可以在后面的操作中避免使用失效的迭代器。 2）使用STL提供的一些算法和容器操作，这些操作能够避免产生迭代器失效的情况，例如使用erase()函数时，返回一个新的迭代器指向被删除元素的后一个元素