1. `LevelDB`项目用`Compaction`机制目的?
    * 优化读取效率：通过合并和排序SSTable，减少文件数量，使得读取操作可以更快地找到所需数据
    * 减少文件数量：Compaction会将多个SSTable合并为一个或多个更大的文件，从而减少磁盘上的文件数量，降低文件管理的复杂性
    * 删除过期数据：Compaction会清理掉被删除或过期的记录，从而减少存储空间的浪费
    * 维护数据一致性：通过合并不同层级的SSTables，确保数据的最新版本被保留，旧版本的数据被删除（不是所有旧版本都能删，而是删对于此操作中最小的快照序列号可见的，即比当前快照小的序列号的键）
    * 控制存储空间：通过限制每个层级的文件大小和数量，避免磁盘空间的过度使用
2. 布隆过滤器原理?如果布隆过滤器判断不在那么一定不在吗?如果判断在就一定在吗?
   布隆过滤器原理:使用大小为`m bit`的数组作为存储空间,使用`k`个哈希函数进行计算.每次查找一个元素是否存在时,首先通过`k`个哈希函数分别计算该元素的哈希值,然后判断哈希值对应位置的比特数数组元素是否为1(即将计算得到的哈希值作为布隆过滤器的下标去看对应位置是否为1).如果有任意一位不为1,则可以判断该元素不存在.如果布隆过滤器判定一个元素不存在,那么可以得出该元素肯定不存在,但如果布隆过滤器判定一个元素存在,则有一定的误报率(因为哈希冲突导致位被其它元素覆盖，就可能将未存在的元素判为已存在)
3. `STL`的智能指针?
   智能指针是一种用于管理动态分配内存的工具。在C++中，使用new运算符分配内存后，需要手动使用delete运算符释放该内存，否则可能会导致内存泄漏和程序崩溃。而智能指针可以自动管理内存，当指针不再使用时，会自动调用delete运算符释放内存，从而避免内存泄漏和程序崩溃的问题。智能指针的实现通常基于C++语言的RAII机制。RAII机制是通过在对象的构造函数中获取资源，并在析构函数中释放资源来实现的。智能指针解决了C++中内存泄露的问题，C++中new与delete不匹配问题，new开辟新空间后忘记delete；空指针与野指针问题；解决了C++中对象重复释放问题.`C++`提供了三种智能指针:1）shared_ptr：采用引用计数器的方法，多个智能指针可以共享同一个对象，当计数为0的时候会自动的释放动态分配的资源；2）unique_ptr：独占式智能指针，不能共享同一个对象，当智能指针被销毁时，它会释放对象的内存。3）weak_ptr：弱引用智能指针，不会增加对象的引用计数，用于避免shared_ptr循环引用时的内存泄漏问题
4. `weak_ptr`怎么解决`shared_ptr`出现的交叉引用的?
   交叉引用问题:当两个或多个对象通过 shared_ptr 互相引用时，会导致引用计数无法归零，内存无法释放.
   虽然智能指针会减少内存泄漏的可能性，但是如果使用智能指针的方式不对，一样会造成内存泄漏。比较典型的情况是循环引用问题；将其中一个`shared_ptr`改成`weak_ptr`即可，由于`weak_ptr`不会增加`shared_ptr`的引用计数，因此不会阻止对象被销毁
5. 为什么用`B+`树索引,而不用`B`树索引,也不用红黑树索引呢?

6. 解释一下布隆过滤器.如果用布隆过滤器判断不在,那么就是不在吗?如果判断在,那么就是在吗?
   
   