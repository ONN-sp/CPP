1. `HTTP`通常是基于`TCP`的,即`HTTP1/1.1/2`都是基于`TCP`的,但是`HTTP3`是基于`QUIC(UDP)`的
2. `TCP`中同时利用流量控制和拥塞控制,最终实际发送窗口=`min(流量控制发送窗口, 拥塞窗口)`
3. 常见的`HTTP`状态码:1XX(信息性状态码);2XX(成功状态码);3XX(重定向状态码);4XX(客户端错误状态码);5XX(服务器错误状态码)
   * 100(Continue):表示目前为止很正常,客户端可以继续发送请求或者忽略这个响应
   * 200(OK)
   * 204(Not Content):请求已经成功处理,但是返回的响应报文不包含实体的主体部分,一般在只需要从客户端往服务器发送信息,而不需要返回数据时使用
   * 206(Partial Content):表示客户端进行了范围请求,响应报文包含由`Content-Range`指定范围的实体内容
   * 301(Moved Permanently):永久性重定向
   * 302(Found):临时性重定向
   * 303(See Other):临时性重定向,但是303明确要求客户端采用`GET`方法获取资源
   * 304(Not Modified):如果请求报文首部包含一些条件,如`If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since`,如果不满足条件,则服务器会返回304状态码
   * 307(Temporary Redirect):临时重定向,但是307要求浏览器不会把重定向请求的`POST`方法改成`GET`方法
   * 400(Bad Request):请求报文中存在语法错误
   * 401(Unauthorized):该状态码表示发送的请求需要有认证信息.如果之前已进行过一次请求,则表示用户认证失败
   * 403(Forbidden):请求被拒绝
   * 404(Not Found)
   * 500(internal Server Error):服务器正在执行请求时发生错误
   * 503(Service Unavailable):服务器暂时处于超负载或正在进行停机维护,现在无法处理请求
4. 服务器出现大量`CLOSE_WAIT`状态是为什么?怎么解决?
   `close_wait`状态是`TCP`四次挥手的时候服务端收到客户端的`FIN`但是没有发生字节的`FIN`时出现的,服务器出现大量`close_wait`的原因有两种:
   * 服务器内部业务处理占用了过多时间,都没能处理完业务;或者还有数据需要发送;或者服务器的业务逻辑有问题,没有执行`close()`方法
   * 服务器的父进程派生出子进程,子进程继承了`socket`,收到`FIN`的时候子进程处理但父进程没有处理该信号,导致`socket`的引用不为0无法回收
   * 解决方法:
     - 停止应用程序
     - 修改程序里的bug
  