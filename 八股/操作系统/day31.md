1. 协程：协作式调度的用户态线程，可以理解为一个线程里有多个协程
   * 线程调度多数是抢占式的，由操作系统内核决定何时切换，这需要复杂的上下文切换。而协程是协作式的，协程是用户自己来编写调度逻辑的，另一个协程才能继续执行，避免了不必要的上下文切换（没有用户态和内核态间的切换），它的切换效率极高
   * 协程的创建、调度和销毁完全由用户的程序或语言运行时管理，不涉及操作系统内核
   * 协程也有切换，通常只是保存/恢复少量寄存器状态和栈信息，比线程切换快很多
   * 一个进程可以有多个线程，一个线程可以有多个协程
2. 协程的不足
   * 线程可以在cpu的不同核上并行，但是无法将一个线程的多个协程分摊到多个核上
   * 协程执行中不能有阻塞操作，否则整个线程的所有协程都会被阻塞（因为协程不会有内核态自动切换机制）；线程如果阻塞，cpu是会自动切换到其它线程中执行的
   * 调试困难：协程的调度是隐式的，堆栈信息不如线程清晰，难排查
3. 多线程多用于CPU密集型（计算等），利用多核实现真正并行；多协程多用于IO密集型，极低的切换开销
4. 为什么muduo不用协程？
   C++11没有成熟的协程支持，C++20才正式引入协程。并且muduo将线程与cpu核心绑定，一般工作子线程数=核心数，避免了频繁的切换
5. 使用原子操作通常是需要保护的共享数据是一个简单的整数或指针，而不是一大段代码（临界区）或复杂的数据结构，原子操作可能会引起不好调试的并发bug。只有当性能分析（Profiling）明确显示互斥锁成为系统瓶颈时，才考虑使用原子操作来优化特定的、简单的计数器或标志位。原子操作性能更好的原因是：它避免了锁竞争带来的线程阻塞、内核态切换和调度延迟，全程在用户态完成
6. 一般上下文切换是由系统调用或中断触发，此时会伴随着用户态到内核态的切换
7. 同步、异步、阻塞、非阻塞
   * 同步：调用者主动等待结果并返回
   * 异步：调用者不等待，结果由系统通知
   * 阻塞：线程被挂起，CPU不往下执行
   * 非阻塞：线程不被挂起，CPU继续往下执行
8. 一个异步非阻塞场景：webserver的异步日志双缓冲区对于生产者来说就是异步非阻塞的，生产者把日志放进缓冲区不等待就立刻返回，生产者不等待磁盘io结果（满足异步）；生产者只要产生日志就将其写到缓冲区，不会因为后端日志线程的刷写磁盘操作而使生存线程阻塞挂起，满足非阻塞
9. 在现代计算机体系结构中，编译器和处理器会对指令进行重排序优化以提高性能。在单线程环境中，这不会影响程序正确性（单线程也可能导致重排序（比如int x=1;int y=2;int z=x+y;这个x和y赋值指令就可能重排序但不会影响结果），但是最终结果是不会影响程序的最终结果（编译器和处理器有两个规则：如果操作B依赖于操作A的结果，那么B不会排到A之前；所有优化必须保证程序的可观察行为（输出cout、文件操作等）与代码顺序执行时一致），但在多线程中，这种重排序可能导致其它线程看到不一致的内存状态,比如
    ```C++
    // 线程1：生产者
   void producer() {
      data.store(42, std::memory_order_relaxed);  // 问题：使用relaxed
      ready.store(true, std::memory_order_relaxed); // 问题：使用relaxed
   }
   // 线程2：消费者
   void consumer() {
      while (!ready.load(std::memory_order_relaxed)) { // 问题：使用relaxed
         // 忙等待
      }
      std::cout << "Data: " << data.load(std::memory_order_relaxed) << std::endl;
   }
   ```
   编译器或处理器可能会重排序指令，导致ready在data之前被设置为true；那么消费者线程可能看到ready=true时，但看不到data的最新值42
10. C++标准库中原子操作默认使用的内存序是memory_order_seq_cst，提供顺序一致性。所有线程看到的原子操作顺序是一致的，且与程序中的顺序（代码顺序）相同。又比如：std::memory_order_acquire:保证在当前操作之后的所有读写操作不会被重排序到当前操作之前
11. 原子操作可以显示指定内存序，像其它同步原语，如互斥锁等，它们是在底层就自动处理了内存序的问题的。lock()内部包含了"获取"语义的内存屏障，也就是在成功调用 lock() 之后的所有内存操作（即临界区内的代码），保证能看到之前任何线程在释放同一个锁之前的所有修改。这防止了临界区内的读操作被重排序到 lock() 之前，也确保了能看到最新的数据。unlock()内部包含了"释放"语义的内存屏障，也就是在调用 unlock() 之前的所有内存操作（即临界区内的所有修改），保证会对下一个成功 lock() 的线程可见。这防止了临界区内的写操作被重排序到 unlock() 之后
12. 内存屏障也称为内存栅栏，是CPU或编译器提供的一种指令，用于强制限制内存操作的顺序。现代计算机优化时会对指令重排序，在多线程里面就可能会导致不一致性，因此需要内存屏障来保证指令顺序，它用来防止屏障前后的指令被重排序（如：写屏障：确保所有在屏障之前的写入操作完成后，才执行屏障之后的写入操作；读屏障：确保所有在屏障之前的读取操作完成后，才执行屏障之后的读取操作；全屏障：确保屏障前的所有操作完成后，才执行屏障后的操作）。内存屏障会限制处理器的优化能力，需要谨慎使用，特别是全屏障，性能影响最大
    