1. 函数调用过程栈的变化:`C++`函数调用的压栈过程:当主函数调用到某个函数A时,编译器此时会将主函数的运行状态进行压栈;再将函数A的返回地址、A的参数从右到左、A函数定义变量依次压栈;在返回的时候会从栈顶依次弹出
2. 函数指针:`int (*pf)(const int&, const int&);`,一个函数名就是一个指针,它指向函数的代码,函数指针的赋值方法:指针名=函数名;指针名=&函数名
3. 宏定义和`typedef`区别
    * 宏主要用于定义常量及书写复杂的内容;`typedef`主要用于定义类型别名
    * 宏替换发生在编译阶段之前(预处理阶段),属于文本插入替换;`typedef`是编译的一部分
    * 宏不检查类型;`typedef`会检查数据类型
    * 宏不是语句,不在最后加分号;`typedef`是语句,要加分号标识结束
    * 注意对指针的操作,`typedef char* p_char`和`#define p_char char*`区别巨大
4. `define`和`const`的区别
   * `define`是在编译的预处理阶段;`const`是在编译、运行阶段
   * `define`只是将宏进行名称替换,在内存中会产生多个相同的备份;`const`在程序运行中只有一个备份
   * 宏不检查类型;`const`会检查数据类型
   * 宏定义的数据没有分配内存空间,只是插入替换掉;`const`定义的变量只是值不能改变,但要分配内存空间  
5. 为什么模板类一般都是放在一个`.h`文件中?
   * 模板定义很特殊,它的定义不会分配内存,和普通变量不一样.由`template<...>`处理的任何东西都意味着编译器在当时不会分配存储空间,它一直处于等待状态直到被一个模板实例告知.所以为了容易使用,几乎总是在头文件中放置全部的模板声明和定义
6. `cout`和`printf`的区别:`cout<<`不是函数,而是一个`std::ostream`对象,它后面可以跟不同的类型是因为`cout<<`已存在针对各种类型数据的重载,所以会自动识别数据的类型
7. 当程序中有函数重载时,函数的匹配原则和顺序是什么?
   * 函数名查找
   * 确定候选函数
   * 寻找最佳匹配
8. 重载运算符:
   * 利用`operator`关键字
   * 两种重载方式:成员函数和全局函数(通常和`friend`结合使用)
9.  定义和声明的区别
   * 如果是变量:从编译原理上来说,声明仅仅是告诉编译器,有个类型的变量会被使用,但是编译器不会为它分配内存;而定义是分配了内存的
   * 如果是函数:声明一般在头文件里,也是用来让编译器知道这个函数的存在;定义一般放在源文件里,具体就是函数的实现过程
10. 全局变量和`static`变量的区别:全局变量和静态变量都是存储在静态存储区的.区别在于非静态全局变量和`static`变量:当一个源程序由多个源文件组成时,非静态全局变量在多个文件间都是有效的;而`static`变量只在定义该变量的源文件内有效
11. 静态成员变量和普通成员变量的区别
    * 生命周期:静态成员变量从类被加载开始到类被销毁,一直存在;普通成员变量只有在类创建对象后才开始,对象结束,它的生命周期结束
    * 共享方式:静态成员变量是全部类对象共享(因为静态成员变量只属于类本身,不属于某个对象);普通成员变量是每隔对象单独享用的
    * 定义位置:普通成员变量存储在栈或堆中,而静态成员变量存储在静态存储区
    * 初始化位置:普通成员变量在类中初始;静态成员变量在类外初始化
12. 全局静态变量和局部静态变量
    * 全局静态变量:作用域限制在定义它的文件内部,无法被其它文件访问
    * 局部静态变量:作用域限制在定义它的函数内部,但生命周期是全局的,即生命周期是整个程序运行期间
13. `ifdef endif`可以实现条件编译,即满足某条件时才后续程序进行编译,否则不编译这一段程序.在头文件中使用`#define、#ifndef、#ifdef、#endif`可以避免头文件重定义(在一个大的项目中,可能会有多个文件同时包含一个头文件,当这些文件编译链接成一个可执行文件时,就会出现大量重定义)
14. 隐式转换,如何消除
    * 基本数据类型的转换以取值范围作为转换基础(保证精度不丢失).隐式转换发生在从小->大的转换中.如;`char->int`、`int->long`等
    * `C++`中构造函数可以进行类型转换,特别是单参数构造函数,允许从构造函数的参数类型到类类型的隐式转换(`Example ex = 42;<=>Example ex(42)`),利用`explicit`可以禁止隐式转换
15. 如何在不使用额外空间的情况下,交换两个数?
    * `x=x+y;y=x-y;x=x-y`
    * `x=x^y;y=x^y;x=x^y;x^=y^=x`
16. `strcpy`和`memcpy`的区别
    * 复制的内容不同:`strcpy`只能复制字符串,而`memcpy`可以复制任意内容
    * 复制的方法不同:`strcpy`不需要指定长度,它遇到被复制字符串的结束符`'\0'`就结束;而`memcpy`根据给定的第三个参数决定复制的长度
    * 性能不同:`strcpy`需要检查结束符其性能比`memcpy`更差